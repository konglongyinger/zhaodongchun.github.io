<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用框架Hexo在IPFS上搭建个人博客]]></title>
    <url>%2F2018%2F03%2F07%2FHexo2%2F</url>
    <content type="text"><![CDATA[Hexo+IPFS [Mac环境]IPFS是基于区块链的星际文件系统（IPFS），将博客挂在IPFS的区块链上，不需要折腾服务器，不需要各种配置，只要买个域名就行。Hexo 是一个快速、简洁且高效的博客框架。 1. 配置HEXO1) 安装 Node.js 在安装HEXO前，您必须检查电脑中是否已安装Node.js.用下面命令查询已安装node版本1node --version 2) 安装 HEXO 接下来只需要使用 npm 即可完成 Hexo 的安装12npm install hexo -gnpm install hexo-cli -g 3) 创建本地工作目录 public下创建一个文件夹,如blog-ipfs 12cd ~/public/mkdir blog-ipfs 4) 初始化你的本地站点 然后进入blog-ipfs里安装Hexo 12cd blog-ipfshexo init 5) 生成静态页面1hexo generate 6) 启动服务 启动本地服务，进行文章预览调试1hexo server 浏览器输入http://localhost:4000 浏览器端出现以下页面 2. 自定义网站模版和内容2.1 设置个人模版hexo提供了一个默认模版(上图)，如果想更改成自己喜欢的模版怎么办? 1）先定位到Hexo站点目录下，在终端输入以下命令先下载模版 12cd blog-ipfsgit clone https://github.com/beevesnoodles/hexo-theme-grace.git themes/grace 2）下载完成后，阅读README.md文档，按照文档步骤安装插件12npm install hexo-renderer-sass --savenpm install hexo-generator-feed --save 3）修改配置文件_config.yml中theme属性为theme: grace，启用模版。 4）在终端继续输入以下命令完成模版调试1hexo server --debug 出现Database saved，浏览器里输入 http://localhost:4000/ 查看你的站点了 2.2 使用Atom更改内容如果没有安装atom.先把Atom下载下来，阅读官方文档飞行手册，完成配置。1）终端执行下面命令，用atom打开12cd ~/public/blog-ipfsatom . 2）使用atom修改source文件夹下hello-world.md文件123456---title: 使用框架Hexo在IPFS上搭建个人博客categories: Hexo---![github](http://p3d3seyjq.bkt.clouddn.com/github.png)这是我的第一篇博客！ 3）打开根目录下_config.yml文件，设置语言和昵称，详情阅读Next模版 123456title: LEO&apos;S BLOGsubtitle:description:author: 赵东春language: zh-CNtimezone: 4）调试 1hexo server --debug 浏览器端出现最终页面效果: 5）最后执行下面命令生成静态网页1hexo g 3. 配置IPFS3.1 安装1) 下载，进入IPFS官方下载地址，点击”download go-ipfs”下载压缩包。 2)解压，压缩包解压后得到一个go-ipfs的文件夹，终端打开12cd go-ipfsls 查看文件夹下有五个文件，LICENSE build-log ipfs README.md install.sh 3）安装，用下面命令将其中的ipfs文件移动到文件夹/usr/local/bin中1mv ipfs /usr/local/bin/ipfs 4）测试，是否安装成功12345ipfs helpUSAGE: ipfs - Global p2p merkle-dag filesystem.... 3.2 启动本地IPFS节点1) 先初始化IPFS1ipfs init 2) 用下面命令查看文件是否存在123cd ~/.ipfslsopen ./ 3) 启动节点服务器1ipfs daemon 此时，你可以在http://localhost:5001/webui打开自己的操作台。 3.3 将Hexo博客部署到IPFS节点上Hexo是一个静态博客生成器，执行hexo generate后，会在博客目录生成/Public目录,该目录即为全部博客内容. 1) 终端定位到博客所在public目录，执行ipfs add -r public命令123cd ~/public/blog-ipfsipfs add -r publicadded QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY public QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY即为博客网站的site_hash,你可以通过任意运行IPFS的节点访问 2) 浏览器访问 https://ipfs.io/ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY/ 效果如下: 注意：部署到ipfs节点之前，需运行vpn。css丢失不用管，后面一绑定域名，重定向就好了。 3.4 网络同步这步很重要，很多问题，都是因为没有同步造成的，切记：发布IPNS之前要同时开启同步和VPN.1ipfs daemon 3.5 发布到IPNS上1) 发布,需另启一终端12$ ipfs name publish QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKYPublished to QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi: /ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY 2) 验证12$ ipfs name resolve QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi/ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY 3) IPNS访问https://ipfs.io/ipns/QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi/ 4. 绑定独立域名刚好我有一个zhaodongchun.top域名，只需要将zhaodongchun.top解析到上述地址即可。 1) 添加TXT记录为dnslink=/ipns/QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi 2)添加域名A记录为gateway.ipfs.io 确保vpn和节点服务器启动状态，浏览器输入域名：zhaodongchun.top 5. 更新，优化上面讲的是hexo博客的生成与部署，你可以对Hexo进行进一步的配置和优化，发表新的文章，然后hexo g生成新的public，再通过ipfs add即ipfs publish即可实时更新在线博客。步骤如下,别忘了vpn同时开启。1234ipfs add -r public/ipfs daemonipfs name publish QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKYipfs name resolve QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（四）]]></title>
    <url>%2F2018%2F03%2F05%2FTruffle4%2F</url>
    <content type="text"><![CDATA[这次用Truffles实现“一刻永流传”，网站效果详看网址。学习在区块链上刻字是怎么实现的？ 开始总结]]></content>
      <categories>
        <category>Truffle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（三）]]></title>
    <url>%2F2018%2F03%2F04%2FTruffle3%2F</url>
    <content type="text"><![CDATA[前端增加一按钮和一个输入框，如果在输入框输入数据，点 击按钮后，前端自动修改数据。 开始总结]]></content>
      <categories>
        <category>Truffle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（二）]]></title>
    <url>%2F2018%2F03%2F03%2FTruffle2%2F</url>
    <content type="text"><![CDATA[用Truffle运行一个叫tutorialtoken的TT代币钱包demo，实现类似于钱包imtoken的功能，详看官方文档。 1. 打包前后端应用1) 终端中创建一个工作目录12mkdir oz-workspacecd oz-workspace 2) 安装tutorialtoken模版1truffle unbox tutorialtoken 3) 安装第三方库1npm install zeppelin-solidity 2. 创建”TutorialToken”智能合约1) 在contracts/文件夹下创建一个TutorialToken.sol文件,增加以下代码1234pragma solidity ^0.4.17;import &apos;zeppelin-solidity/contracts/token/ERC20/StandardToken.sol&apos;;contract TutorialToken is StandardToken &#123;&#125; 2) 设置代币参数，增加以下代码块到合约中1234string public name = &apos;TutorialToken&apos;;string public symbol = &apos;TT&apos;;uint8 public decimals = 2;uint public INITIAL_SUPPLY = 12000; 3) 完成合约，在上面代码块下面增加下面代码1234function TutorialToken() public &#123; totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY;&#125; 3. 编译和部署智能合约1) 在migrations/文件夹下创建一个2_deploy_contracts.js文件，增加以下代码1234var TutorialToken = artifacts.require(&quot;TutorialToken&quot;);module.exports = function(deployer) &#123; deployer.deploy(TutorialToken);&#125;; 2) 准备编译合约，使用一个工具Ganache，下载运行后,将会生成一个端口为7545的区块链。 3) 编译1truffle compile 4) 部署1truffle migrate 输出类似下面结果123456789101112131415Using network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956Saving artifacts...Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts... Ganache会列出交易记录 4. 和新代币交互1) 拷贝Ganache工具中HTTP://127.0.0.1:7545粘贴到MetaMask，创建一个7545网络;拷贝Ganache工具中助记词candy maple cake sugar pudding cream honey rich smooth crumble sweet treat到MetaMask中的”7545”网络”Custom RPC”中。 2) 想办法vpn,否则网页端不显示代币TT余额Balance: 3) 终端，启动服务1npm run dev 浏览器窗口自动打开，界面如下 4) 下面给不同的账户转账。Ganache中查看，现在有10个账户，第一个账户已经有余额，从另外几个账户中选择一个账户的地址（建议第二个账户），复制后粘贴到网页端的“Address”框中， 在”Amount”框中输入2000。 5) 点击”Transfer”，弹出MetaMask交易确认界面。 6) 点击”Submit”，交易处理成功后显示”Transfer successful”，Ganache显示交易数据。 7) 在网页端MetaMask,更改第一个账户到第二个账户 8) 在浏览器中刷新，将会连接到当前MetaMask账户，显示余额为2000 TT,代表转账成功。]]></content>
      <categories>
        <category>Truffle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（一）]]></title>
    <url>%2F2018%2F03%2F02%2FTruffle1%2F</url>
    <content type="text"><![CDATA[Truffle是针对基于以太坊的Solidity语言的一套开发框架。本身基于Javascript。 1. 简单创建一个项目 1) 安装truffle框架1npm install -g truffle 2) 卸载truffle框架1npm uninstall -g truffle 3) 查看版本123$ truffle versionTruffle v4.1.0 (core: 4.1.0)Solidity v0.4.19 (solc-js)s 4) 创建项目12mkdir demotruffle init 简单分析：有三个文件夹contracts migrations test结论：最简单truffle框架，没有和任何前端结合。 2. 使用BOXES创建一个项目使用truffle的最佳姿势是使用集成好的BOXES生成项目 1) 安装truffle box 1truffle unbox react 如果前端使用react，推荐使用react盒子。 2) 目录结构分析 简单分析：有八个文件夹config contracts migrations node_modules public scripts src test 重要文件1：contract文件夹用来存放合约，其中simpleStorage.sol文件为默认合约，可以自定义修改 重要文件2：src文件夹用来存放代码，其中App.js用来修改代码 重要文件3：最底部truffle.js很有用 3. 如何运行一个项目总体流程是：先编译合约，再部署合约，然后同步MetaMask和本地私有网络账号，最后运行服务。 3.1 编译12truffle developcompile develop产生一个本地测试区块链，得到一个区块链服务器地址http://localhost:9545/和十个账号Accounts:，以及12个单词的助记词Mnemonic： compile编译后得到一个build文件夹,此文件夹存放abi和字节码 3.2 部署1migrate 部署后得到一个合约地址simpleStorage，这样当前网络上已经部署合约。 3.3 MetaMask和本地私有网络账号同步对比本地网络地址localhost：9545和网页端本地网络地址localhost:8545，需要将网页端和本地链接起来 1) 拷贝本地网络地址http://localhost:9545/ 2) 定位到网页端metamask钱包中custom RPC,将其粘贴进来 3) 拷贝助记词到MetaMask中，通过此方法不需要使用web3转账。 用web3解决网络钱包中没有钱的问题 12345678web3.eth.getBalance("0x821aea9a577a9b44299b9c15c88cf3087f3b5544")//得到余额var count=web3.toWei(50,'ether');count;count//50eth转换为位web3.eth.sendTransaction(&#123;from:"",to:"",value:count&#125;)//发送count从钱包地址1到钱包地址2. 运行完代码后，到网页端metamask钱包查看余额，为150eth就对了。 3.4 启动服务1npm run start 启动第二个终端，运行npm run start,如果结果为5则正常]]></content>
      <categories>
        <category>Truffle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（四)]]></title>
    <url>%2F2018%2F03%2F01%2FReact4%2F</url>
    <content type="text"><![CDATA[本次学习后端知识，学习JSX和组件。明白React唯一不可缺少的是render函数 1. React前端思维方式1） 安装create-react-app安装包确认Node.js和npm安装好之后，执行下面命令安装1npm install --global create-react-app 2） 初始化项目先创建一个demo项目1create-react-app demo 3）终端，运行下面代码12cd demonpm start 恭喜，第一个React应用诞生！ 2. 案例学习2.1 案例一再开一终端,demo目录下运行atom .打开目录，先找到入口index.js，拷贝以下代码 123456let str=&quot;这是一个测试&quot;;ReactDom.render( &lt;span&gt; &#123;str&#125; &lt;/span&gt; ) 浏览器端效果 1这是一个测试 注意：JEX语法的实现用花括号{}，注意let和var作用域的不同，var以后尽量少用。 2.2 案例二 通过此案例学习JSX遍历（map） 123456789 let labels=[ &quot;xixi&quot;, &quot;haha&quot; ];labels.map(function(s)&#123; return( &lt;h1&gt;&#123;s&#125;&lt;/h1&gt; )&#125;) 浏览器端效果 12xixihaha 注意：数组里可以放标签对象，map是js代码中的数组遍历的函数，js代码可以嵌入xml,xml代码也可以嵌入js 2.3 案例三1234567891011121314151617181920import React,&#123;Component&#125; from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;; let persons = [&quot;汪峰&quot;,&quot;章子怡&quot;,&quot;萨贝岭&quot;] class Person extends Component &#123; render() &#123; return ( &lt;div&gt; &#123; persons.map((name) =&gt; &#123; return &lt;h1&gt;姓名：&#123;name&#125;&lt;/h1&gt; &#125;) &#125; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Person /&gt;, document.getElementById(&apos;root&apos;) ); 浏览器端效果 123姓名：汪峰姓名：章子怡姓名：萨贝岭 注意：第一行{Component}的意思是从库中导入基类Component,第四行class Person extends Component这句话的意思是创建一个叫Person的组件类，Person的父类就是Component 3. 设计React组件3.1. 组件的创建 1234567891011121314class Person extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;me&lt;/h1&gt; &lt;h1&gt;you&lt;/h1&gt; &lt;/div&gt; ) &#125; &#125;ReactDom.render( &lt;Person /&gt;,document.getElementById(&apos;root&apos;)); 浏览器端效果 12meyou 3.2. 组件的生命周期 1） 装载过程 2) 更新过程 3) 卸载过程 3.3. React组件的state和prop的局限学习如何使用状态机变量测试一个输入框，输入框输入数字，下面展示相应数字12345textarea style=&#123;&#123; width:400, height:200 &#125;&#125; defaulvalue:&quot;请输入内容...&quot; 创建一个构造函数,用来存储状态机变量123456constructor(props)&#123; super(props); this.state=&#123; textValue:&quot;请输入内容...&quot; &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（三)]]></title>
    <url>%2F2018%2F02%2F28%2FReact3%2F</url>
    <content type="text"><![CDATA[本节我们学会使用web中的Flex布局 学习之前三必问开始学习基本概念容器的flexbox属性项目的flexbox属性实现骰子效果 1. 学习之前三必问1.1 Flex布局是什么Flex布局是W3C提出了一种新的网页布局（layout）方案，Flex是Flexible Box的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。 总结一句话来说：Flex布局就是一种弹性的网页布局方式。 1.2 为什么学习Flex布局1）传统布局 传统布局解决方案:基于盒状模型，依赖 display属性 + position属性 + float属性。 2）Flex布局 Flex布局解决方案:对于那些特殊布局非常方便，比如，垂直居中。 对比两种布局方式结论为：Flex布局将成为未来布局的首选方案 1.3 怎么学习Flex布局1）把握一个中心 任何一个容器都可以指定为Flex布局 2）理解两个概念 Flex 容器（flex container）`Flex 项目（flex item） 3）运用多个属性 6个属性设置在容器上 flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 6个属性设置在项目上 orderflex-growflex-shrinkflex-basisflexalign-self 总结一句话就是：搞清楚container和item的异同，高频练习flex属性就好了 2. 开始学习基本概念1）第一个概念：Flex容器是采用Flex布局的元素2）第二个概念：Flex项目是容器的子元素 图释：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。项目默认沿主轴排列，主轴很重要，运用flex属性需要先判断主轴方向。 如何判断主轴 项目（item）排序方式如果从上往下，上下方向为主轴项目（item）排序方式如果从左往右，左右方向为主轴 牢记一句话就是：容器里包括项目，项目排序方向为主轴 3. 容器的flexbox属性 flex-direction属性 flex-wrap flex-flow justify-content align-items align-content 4. 项目的flexbox属性5. 实现骰子效果 5.1 初始化环境1）常用包 Reactreact-domreact-scripts 2）安装包1npm install --save react-redux 3）卸载包1npm uninstall --save react-redux 4）将react-redux安装在devDependencies里面 1npm install --save-dev react-redux 5）将react-redux卸载在devDependencies里面1npm uninstall --save-dev react-redux 6）启动项目12cd my-Appnpm start 5.2 初识目录结构执行顺序是先定位到index.js render 函数里就两个函数: 第一个参数放一个 标签对象，&lt;div&gt;&lt;/div&gt;或&lt;span&gt;&lt;/span&gt; 第二个参数放一个节点 注意以下几点： react里面的语法属于JSX语法 JSX相当于js和xml的结合体 XML范围大于HTML HTML是XML的一个子集 如果想让body里面的div按照flex布局，那么需要将container这个body设置为flex1display:flex; 盒子不再重叠只有当display属性为flex时，才有主轴和交叉轴概念。 容器(body)的flex属性12345678910111213141516171819body&#123; flex-direction:row; flex-direction:column; flex-direction:row-reverse; flex-direction:column-reverse; flex-wrap:nowrap; flex-wrap:wrap; flex-flow:row wrap; justify-content:flex-start;//主轴 justify-content:flex-end; justify-content:center; justify-content:space-between; justify-content:space-around; align-items:flex-start;//交叉轴 align-items:flex-end;//交叉轴 align-items:stretch;//交叉轴&#125; 项目(item)的flex属性12345678910div&#123; order:0; flex-grow:1; flex-shrink:1; flex-grow:1; flex-basis:300px;//固定，flex-shrink和grow将不起作用 flex:0 1 auto;//是否压缩，拉伸，值 align-self:flex-start;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（二）]]></title>
    <url>%2F2018%2F02%2F26%2FReact2%2F</url>
    <content type="text"><![CDATA[运行一个todolist项目，学习react运行原理。 1. 了解并会使用React对比html+css+js和react有什么不同先阅读官网文档 1） 设置环境 运行下面命令，确认已经安装npm1npm -v 2）工具下载1sudo npm install create-react-app -g 3）初始化1create-react-app todolist 4）运行测试。 12cd todolistnpm run start 稍等片刻，服务如果打开localhost:3000，代表服务已经运行成功,以后我们修改值后，都会在这个终端显示结果。 2. 更新内容保持服务打开，我们需要再打开一个atom终端，两个atom同时运行，一个用来开启服务，另一个用来修改值用于测试。 1）运行命令12cd todolistatom . 在atom中打开todolist目录 2）分析目录结构。 src目录 App.js 写一个标签 index.js 只有一个作用 package.json public目录 index.html 在atom中同时打开上面四个文件，结合浏览器，我们学习下这几个文件的关系。 3）编辑src/App.js找到下面字段：1&lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; 修改为：1&lt;h1 className=&quot;App-title&quot;&gt;Test&lt;/h1&gt; 保存后，你会发现locahost页面也相应更新。 3. 接口1） 导入,导出 尝试修改index.js文件,定位此代码1import App from &apos;./App&apos;; 更改为1import App,&#123;Test3,Test2&#125; from &apos;./App&apos;; 切换到App.js文件，查看页面底部import后面的 理解导入导出，导入两种方式。一种是名字，一种带括号的。 2）传值 index.js =&gt; app.js 动态添加组件，并实时渲染出来]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（一）]]></title>
    <url>%2F2018%2F02%2F26%2FReact1%2F</url>
    <content type="text"><![CDATA[React 是一个用于构建用户界面的 JAVASCRIPT 库，React主要用于构建UI。先阅读官方文档。 1. 开始之前1) 为什么学习React？ 答：学会了react可以用最快的速度在安卓端和ios端创建轻应用界面UI。轻应用特点： 点开后都是网页，长处是应用审核效率高，短处是做酷炫效果难。 网页只需要开发一次，安卓端和ios端打开后效果是一样的。 2) 怎么学习React? 答：顺序学习下面五项内容。 了解并使用ES6了解并会使用React会使用web中的Flex布局了解react-router 2. 了解并使用ES6我们已经知道了react是javascript库，那么学习库之前需要先熟悉javascript.ECMAScript 和 JavaScript 的关系：前者是后者的语法规格，后者是前者的一种实现。 那么问题又来了，我们为什么要学ECMAScript? 答：ECMAScript6是JavaScript语言的下一代标准,现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器。而且它的目标是使得JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 html+css+js// es =&gt; 语言规范// js =&gt; es规范下的方言(有自己独特的地方，也有不想要的地方)// node =&gt; 基于es规范下的一套方法集合// nvm node 版本管理工具// vim 的使用+linux常用命令 学习之前需要先配置javaScript运行环境。我们选择的是Node.js,Node.js是一个基于Chrome V8引擎的JavaScript运行环境。node还有一个版本管理工具nvm不错，好处在哪，后面说。 3. 安装node3.1 安装node和nvm输入node -v命令查看已安装node版本，如果通过以下命令安装nvm成功,但是不能启动命令，是因为环境变量没有配置12//node -v//brew install nvm 3.2 配置环境1) 定位到根目录123cd ~ls -avim .bash_profile 2) 添加以下命令： 12export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 3)重新source 1source .bash_profile 到此，nvm环境配置安装好了。 使用nvm的好处就是以后更新版本只需要指定版本号，自动切换版本后旧版本的功能也就能用了。 4)测试，新建一个工作目录，然后创建一个test1.js的文件,内容就拷贝下面代码吧。1console.log(&apos;hi!&apos;) 写好后，我们在终端输入下面命令，看下效果1node test1.js 结果：hi! 5）以后每次写完代码，用node 文件名运行就好了。 有时根据需要配合一些nvm命令，用来切换版本实现一些特殊功能等等。 nvm -v 列出nvm所有信息nvm ls-remote 列出可以全部安装的版本号nvm install v7.0.0 下载需要的版本nvm use v7.0.0 切换到固定版本nvm current 查看当前版本nvm ls 查看当前系统内已经安装的版本 4. ES6语言有了node环境，我们在环境下通过案例学习ES6的常用语法。 1）常量const 1234 &#123;const a= 100;console.log(a);//100&#125; 需要注意： ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的 2）变量let,var let是ES6新加的一个变量修饰符，ES6推荐在函数中使用 let 定义变量，而非 var： 123456var a=100;&#123; let a = 200; console.log(a);//200&#125;console.log(a);//100 有几点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let只在最近的代码块中(花括号)有效 let和var 在作用域的问题上是有区别的 let是一个块级的变量声明，只在当前作用域有效 var相反 3）函数functions 函数声明方式: function 方法名（参数列表）{代码块}12function method1()&#123;&#125; 如果函数需要把执行结果返回，就直接用return返回1234567let method1 = function add(a,b)&#123; const c=a+b; return c;&#125;let result = add(1,2);console.log(result);//3 4）箭头函数=&gt; ES6中，箭头函数就是函数的一种简写形式，对比上面普通的声明方式，有什么不同，箭头函数声明方式:（参数列表） =&gt; {代码块}123456let method2 = (a,b) =&gt; &#123; return a+b;&#125;let result = method2(10,5);console.log(result);//15 5）数组 [] []来声明一个数组1let arraya = [1,2,3]; 和其他编程语言一样通过下标取值1console.log(array[2]); 解构赋值1arraya[2]=10; let后面的变量数组和等号右边的数组的下标是统一的12345let arraya = [1,2,3];let [a,b,c]=arraya;console.log(&apos;a:&apos;+a);//a:1console.log(&apos;b:&apos;+b);//b:2console.log(&apos;c:&apos;+c);//c:3 push方法添加数据123let arraya = [45,56];arraya.push(34,23,34);console.log(arraya);//45,56,34,23,34 map方法遍历设置元素并把每一个元素依次传入方法体执行123arraya.map(function(value,index)&#123; console.log(index+&apos;+&apos;+value);&#125;) 如果箭头函数列表只有一个参数，可以省掉括号1234567value =&gt; &#123; console.log(index+&apos;:&apos;+value);&#125;arraya.map(value =&gt; &#123; console.log(index+&apos;:&apos;+value); &#125;) 数组的扩展运算符1234let array = [23,45,6,7]console.log(array);console.log(...array);//结果：23，45，6，7console.log([...array]); 改变元素值1234let array = [23,45,6,7]let array2=array;array2[0]=1;console.log(array); 利用数组的扩展运算符解决复制问题1let array3=[...array]; 利用…实现数组的合并12345let array = [1,2,3,4];let array2 = [5,6,4];let array3 = [1000];let newarray = [...array, ...array2, ...array3,6,5];console.log(newarray); 6）对象{} 声明一个对象 12345const zhangsan=&#123; name:&apos;张三&apos;, age:18, gender:&apos;man&apos;&#125; 修改一个对象 1zhangsan.name=&apos;李四&apos; 对象的解构赋值 12345678let objecta=&#123; name:2, age:10&#125;let &#123;name,age&#125;= objecta;console.log(name);console.log(objecta.name); 7）promise ES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者rejected。promise 是一个类，通过new关键字来实例化一个对象. 123456789 var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调：12p.then((val) =&gt; console.log(&quot;Promise Resolved&quot;, val), (err) =&gt; console.log(&quot;Promise Rejected&quot;, err)); 以下代码模拟一个数据库，等待三秒返回链接成功 1234567function connectServer()&#123; //定时 setTimeout(() =&gt; &#123; console.log(&apos;链接成功&apos;); &#125;,3000);&#125;connectServer(); 如果以上代码测试成功，终端显示链接成功后，再实现下面逻辑,函数功能实现如果链接上数据库ip,打印链接成功，如果不能链接，打印错误 123456789101112131415161718192021function connectP(ip)&#123; let promise = new Promise((resolve,reject) =&gt; &#123; if(ip == &apos;10.0.0.119&apos;)&#123; reject(&apos;错误&apos;) &#125;else&#123; setTimeout(() =&gt; &#123; resolve(&apos;链接成功&apos;) &#125;，3000); &#125; &#125;); return promise;&#125;let promise=connectP(&apos;10.0.0.119&apos;);promise.then((data) =&gt;&#123; console.log(data); &#125;)promise.catch((error) =&gt; &#123; console.log(&apos;error:&apos;+error) &#125;) 8）类class类是同一种物体的抽象概念，类的声明：class+类名{类实现} 1234567class Coin&#123;//构造一个类的实例对象constructor(name,number)&#123; this.name = name; this.number = number;&#125;&#125; 通过new来创建一个对象12let btc = new Coin();console.log(btc.name+&apos;当前数量：&apos;+btc.number);//name当前数量:number 需要注意几点： 方法的声明不需要function关键字 类=&gt;实例对象 this =&gt; 创建的一个新空对象 通过new来创建一个对象 定义一个莱特币，继承虚拟币1234567891011121314151617class Coin&#123;constructor(name,number)&#123; this.name = name; this.number = number;&#125;&#125;class LTC extends Coin&#123; constructor(name,number)&#123; super(); this.number = number*100; this.name = name; &#125;&#125;let ltc = new LTC(&apos;莱特币1&apos;，9999);console.log(ltc); 结果：LTC {name:&#39;莱特币1&#39;，number:999900} 注意以下几点： super() =&gt; 就是父类的构造函数 5. 总结React理念可总结为一个公式：UI=render(data)]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（六）]]></title>
    <url>%2F2018%2F02%2F26%2FSolidity6%2F</url>
    <content type="text"><![CDATA[编写智能合约，构建和部署一个去中心化投票App 1. 投票合约思路： 复制模版改名voting.sol定位到前段代码app.js，更换合约地址和名字将合约拷贝到web端，run，create，submit拷贝合约地址到app.js，替换掉运行truffle develop编辑后npm start,前端启动。 2. 实现不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（五）]]></title>
    <url>%2F2018%2F02%2F09%2FSolidity5%2F</url>
    <content type="text"><![CDATA[12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData = x; &#125; function get() public constant returns (uint) &#123; return storedData; &#125;&#125; 尝试理解一个基本实例 1. 开始之前复盘几个概念枚举：go中关键字iota，solidity中关键字enum结构体： 2. 声明枚举12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.19;contract C &#123; // 声明一个枚举类型ActionChoices // 里面一共有四个值，GoLeft, GoRight, GoStraight, SitStill // 其实位置的值GoLeft等于0，往后逐渐+1 // uint8是无符号整型，它的存储范围是0～255 // ActionChoices相当于是我们自己自定义的一个无符号整型，存储的值的范围由我们自己决定 // 当前案例里面ActionChoices的存储范围为0 ~ 3，在set方法中如果传值超过了3，那么就会越界 enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; // 声明一个ActionChoices类型的变量_choice ActionChoices _choice; // 声明一个ActionChoices类型的常量，defaultChoice // defaultChoice它的值为ActionChoices.GoStraight ActionChoices constant defaultChoice = ActionChoices.GoStraight; // 通过set方法修改变量_choice的值 function setGoStraight(ActionChoices choice) public &#123; _choice = choice; &#125; // get方法，读取变量的_choice的值 function getChoice() constant public returns (ActionChoices) &#123; return _choice; &#125; // 返回常量defaultChoice的值 function getDefaultChoice() pure public returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 12345678910pragma solidity ^0.4.19;contract C &#123; //枚举类型单词首字母大写，里面也是 enum Sex &#123; Man, Women, Unknown &#125; function SexSelf() public view returns (Sex) &#123; return Sex.Man; &#125;&#125; 3. 初始化一个结构体1234567891011pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125;&#125; 123456789101112131415161718192021pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125; //初始化方法一 Person person=Person(30,101,&quot;lillll&quot;); //初始化方法二 Person _person=Person(&#123;stuId:101,age:18,name:&quot;liyecjc&quot;&#125;) //元祖 function getPersonInfo() public view returns (uint,uint,string)&#123; return (person.age,person.stuId,person.name); &#125;&#125; 4. 字典（和go语言的区别）123456pragma solidity ^0.4.19;contract MappingExample &#123;mapping(address=&gt;uint) balances;&#125; 5. 众筹合约1234567891011121314151617181920212223pragma solidity ^0.4.19;contract CrowdFunding &#123;//定义一个结构体类型struct Funder&#123; address addr; //出资人地址 uint amout; //出资总额&#125;//定义一个结构体类型struct Campaign&#123;&#125;//通过campaignID给某个对象赞助function contribute(uint campaignID) public payable &#123; Campaign storage c= Campaigns[campaignID]; c.funders[c.numFunders++]=Funder(&#123;add:msg.sender,amout:msg.sender&#125;)&#125;//判断是否达标&#125; 6. 如何把truffle的demo跑起来1) 安装truffle1npm install -g truffle 2) 运行项目模版12009_demotruffle unbox react 找到src下app.js,复制contract文件夹下的migrations.sol代码到web编译器，登陆mask钱包，切换到测试网络，点击set后点击submit,部署到测试网络。1truffle develop 编译出一个build的文件1npm start 运行 修改app.js,增加按钮修改合约数据]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（四）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity4%2F</url>
    <content type="text"><![CDATA[关键字：固定，动态，memory,storage,bytes,push,索引 1. 开始之前复盘几个概念固定字节数组：bytes关键字后面直接带有数字，例如bytes9 names动态字节数组：bytes关键字后面不接数字，例如bytes namesstorage类型：指针传递，传递指针不传递内容，例如bytes storage namesmemory类型：值传递，传递的是内容，例如bytes memory names 2. 固定大小字节数组转动态大小字节数组（不能直接转换）需求：将bytes9 name9转化为bytes name9 思路：尝试两种方法，第一种方法我们通过索引将固定大小字节数组内内容提取出来，再将其内容存储进一个动态大小字节数组，第二种方法我们通过push方法把固定大小字节数组内内容推送给一个动态大小字节数组。 2.1 第一种方法：通过索引1）创建固定数组2）转换数组 创建存储数组，注意数组类型为memory 通过for循环更新存储数组内内容 12345678910111213141516pragma solidity ^0.4.19;contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public constant returns (bytes) &#123; // 创建一个长度为name9的长度的动态大小字节数组，主要用于存储name9里面的字节内容 bytes memory names = new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return names; &#125; &#125; 2.2 第二种方法：通过push方法1）创建固定数组(为方便记忆理解，将字节数组简写为数组)2）创建一个空动态数组,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组)3）通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push123456789101112131415161718pragma solidity ^0.4.19;// 如果想要使用push，动态大小字节数组必须是storage类型// 通过new bytes(0)创建的状态变量/属性默认为storage类型// 在函数里面通过new bytes(0)创建的状态变量/属性默认为memory类型// memory类型的动态大小字节数组不能使用push，只能通过索引更新内容contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes public names = new bytes(0); //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public &#123; for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names.push(name9[i]); &#125; &#125;&#125; 3.字符串转换为固定大小字节数组需求：将字符串&quot;zhaodongchun&quot;转化为固定数组bytes32 思路：直接转化成功，通过声明变量的方式失败。 3.1 直接转化把字符串&quot;zhaodongchun&quot;通过bytes32()转化为固定数组后，值直接返回给函数123456789pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题// string 转换为固定大小字节数组 只有直接传字面量string时好使contract C &#123; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(&quot;zhaodongchun&quot;); //直接将字面量字符串转换为固定大小字节数组，转换成功 &#125;&#125; 3.2 失败案例1）函数内接参数，通过字符串类型s，值直接返回给函数行参，对比第一种方法，有什么异同。12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //memory类型的string不能转换为固定大小字节数组 function stringToFixedBytes(string s) pure public returns (bytes32) &#123; return bytes32(s); &#125;&#125; 2）编译器提示memory类型的字符串有问题，更改为storage测试依然报错12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //报错 function stringToFixedBytes(string storage s) pure private returns (bytes32) &#123; return bytes32(s); &#125;&#125; 3）如果函数外声明字符串变量，测试依然报错12345678910pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; string s = &quot;liyuechun&quot;; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(s); //报错 &#125;&#125; 4. 固定大小字节数组转换为字符串(不能直接转换)需求：将固定数组bytes9转化为字符串&quot;zhaodongchun&quot; 思路：但是固定可转动态，动态和字符串可直接互转，所以思路是这样，先将固定转动态，再动态转字符串 4.1 通过索引1）创建固定数组2）转换数组 创建存储数组，注意数组类型为memory通过for循环更新存储数组内内容动态数组转换为字符串，将值返回给函数 12345678910111213pragma solidity ^0.4.19;contract C &#123; bytes9 name9=0x6c697975656368756e; function ficTostring() view public returns(string)&#123; bytes memory names=new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return string(names);&#125;&#125; 4.2 通过push方法1）创建固定数组name9(为方便记忆理解，将字节数组简写为数组)2）创建一个空动态数组names,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组)3）通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push4）动态数组names转换为字符串后值返回给函数1234567891011121314pragma solidity ^0.4.19;contract C &#123; // 固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes names = new bytes(0); // 将names9转换为string function fixToString() view public returns (string) &#123; for (uint i=0; i&lt;name9.length; i++) &#123; names.push(name9[i]); &#125; return string(names); &#125;&#125; 5. 固定大小字节数组和可变数组1）固定大小字节数组长度不可修改，内容可以修改12//固定大小字节数组uint [5] T = [1,2,3,4,5]; 2）可变数组可动态修改数组的长度，内容可以修改 12//可变数组 uint [] T = [1,2,3,4,5]; 3）修改可变数组实例 12345678910111213141516171819202122232425 pragma solidity ^0.4.19;contract C &#123; uint [] public T = [1,2,3,4,5]; function setTLength(uint len) public &#123; //可动态修改数组的长度 T.length = len; &#125; function TLength() constant public returns (uint) &#123; return T.length; &#125; // 添加一个数字 function pushANum(uint num) &#123; T.push(num); &#125; //删除整个数组的内容 function deleteTContent() &#123; delete T; &#125;&#125; 6. 二维数组示例 123456789101112131415pragma solidity ^0.4.19;contract C &#123;/* 1 23 45 61 2 34 5 6 */ uint [2][3] T = [[1,2],[3,4],[5,6]]; function T_len() constant public returns (uint) &#123; return T.length; // 3 &#125;&#125;]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（三）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（二）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（一）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity1%2F</url>
    <content type="text"><![CDATA[如果我们掌握了Solidity,就可以开发很多区块链小游戏，说不定还能做出一爆款，收获荣耀和名利。详见官方文档 以太坊开发使用的钱包 通过一个demo简单讲解区块链原理 Solidity面向对象编程 以太坊私有链搭建 联盟链 truffle,embark框架 ipfs怎么配置 如何写一个去中心化拍卖的网站 1. 以太坊开发使用的钱包1) Ethereum Wallet 以太坊完整钱包，发代币需要钱包，下载到本地几十G吧,同步时间比较长，可以以后安装 2) MyEtherWallet 网页版在线轻钱包，不需要同步所有数据 3) Metamask MetaMask是一款在谷歌浏览器Chrome上使用的插件类型的以太坊钱包,不需要下载，安装方法详见此链接吧，安装完后在浏览器右边会出现小狐狸头像，钱包界面下有这几项 main Ethereum Network Ropsten Test Network kovan Test Network Rinkeby Test Network Localhost 8545 custom RPC 第一项是以太坊主网，第二项到第四项是测试网络，主网只在你的产品正式上线才用，测试千万别进主网，我们经常用的是Ropstrn Test Network和Kovan Test Network,如果我们需要内部局域网测试，偶尔也用localhost 8545。获取Ropsrn Test Network可以直接点击buy按钮。获取Kovan Test Network测试网络上的以太坊代币的渠道，需要到这个社区，聊天文本本框内输入此格式@epheph 你的钱包地址epheph会发送eth到你钱包， 4) Parity 偶尔用一下，用于开发联盟链。 2. 两个框架1) truffleframework 进官网后，点开BOXES看菜单项，看看里面都有什么，看到react了吗，以后我们会用到，看看还有什么，发现一个宠物商店，是一个领养猫的app。这些都是现成的demo,集成好的框架 2) embark 这个框架也不错，集成了ipfs,封装好了api,以后用到时我们再详细介绍. 3. 通过一个 demo简单讲解区块链原理打开上面的demo后会有六个菜单项，分别为Hash Block Blockchain Distributed Tokens Coinbase，下面详细解释。 3.1. 了解什么是哈希先看第一项，哈希是什么，在data框内随意输入一个字符试试，会发现下面的哈希值也会同步变化，这就是说你输入内容的同时，网络会根据你的内容计算哈希值。为了便于理解，咱们拿版权保护举个例子，看看版权怎么记录，怎么溯源，怎么存储的问题。 假如有一天我写了一篇文章，提交到了区块链，假如有个后来人改了个字然后说这篇文章是他写的，你怎么判断是谁写的。 看看哈希计算怎么解决这个问题，如果内容一旦发生变化，即使改一个字，哈希值也会变，这样我们只需要存储哈希就行了，不需存取整篇文章。从现实角度讲，盗版，抄袭，无法杜绝，但是通过哈希计算我们可以很简单的识别出谁是原著谁是编著。 原著和编著的区别，从法律角度讲，原著不可随意更改，编著可以随意编撰，不需负法律责任。 3.2. 区块的概念再看第二项block页面有几个值，Block Nonce Data Hash对比上面的四个值，我们先搞清楚什么是挖矿，在Data文本框内输入一个随机数111,再修改Nonce后面文本框内的值，只要你不断尝试，终有一天你会找到一个Nonce值和哈希值匹配上，我们也可以点击下面的Mine按钮，计算机会自动计算出一个正确的Nonce值和哈希值，我们可以理解挖矿就是找Nonce的值，直到满足哈希值要求的条件。1Block+Nonce+Data=Hash 其实从上面公式我们也能分析出来挖矿就是用三个值拼接成一个哈希值的过程 输入下面代码，在电脑终端运行一个小demo，可帮助我们深入理解区块链运行原理，详见春哥的教程 1234sudo npm install blockchain-cli -gblockchainmine zhaobc]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（二）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper2%2F</url>
    <content type="text"><![CDATA[上一篇我们用web scraper这款爬虫工具爬取了单页的数据，这篇我们试下怎么一次设置抓取多页。 1. 看官方视频先进官网,看下Pagination这个视频，虽然是英文中国人也能看懂的，跟着视频操作几遍就好了。 2. 打开我们要抓取的网站3. 抓取数据4. 导出数据4.1 导出到Excel表格抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 4.2 对数据进行筛选从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（一）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper1%2F</url>
    <content type="text"><![CDATA[一直以来，我天天想着爬虫，做梦也想，可是也仅仅是想想罢了，最近需要几百份白皮书，了解到一款叫web scraper的爬虫工具，可以让普通人不敲代码轻松掌握爬虫技巧，下面我盘点下具体做法 1.下载 Web ScraperWeb Scraper是谷歌Chrome浏览器上的一个插件，你需要电脑上安装有chrome浏览器，且已经翻墙，具体怎么翻墙就不多介绍了，自个看外链吧。如果你已经进入谷歌浏览器，请先点击网页左上角的Apps图标,在弹出的菜单中选择Web Store进入Chrome网上应用商店，在搜索框内输入关键词Web scraper,在列表中选中由Martins Balodist提供的Web Scraper,点击右上角的蓝色按钮添加至CHROME,将其添加进谷歌的扩展程序中后会有个蛛网标志出现在搜索框后面。 2. 打开 Web Scraper快捷键 Ctrl + Shift + I / F12打开开发者工具，找到Web Scraper。建议先进官网,看下Watch the intro video这个视频介绍，虽然是英文中国人也能看懂的，如果照葫芦画瓢跟着视频操作几遍，相信你已拿下它了，下面的内容你不看也会爬虫了。 3. 抓取数据我们以抓取block.cc网站的数据为例,先点击进入网站 3.1 新建Sitemap点击 Create New Sitemap,在弹出的下拉菜单中选择Create sitemap,Sitemap name后面的文本框内输入block，这里是自定义名字，容易记忆就行，我自定义的是要抓取的网站名字，Start URL后面的文本框内输入要抓取的网站入口网址https://block.cc/,最后点击按钮Create Sitemap，这样我们就创建了一个名字为block-cc的网站地图，这是我们想抓取数据的网站入口，也就是起点。 3.2 设置Sitemap在页面最下面找到一个蓝色的按钮Add new selector,点击创建选择器，会弹出来选择器设置页面，有下面几项，我们一一解释 Id ———-这个Id需要自定义，最好定义一个英文名字，原则就是简洁，好记。Type ——-这个类型很重要，其实经常用的就三类：“文本”，”链接”，”元素”Selector —-这个是选择器，第一个按钮Select，当按下时，在网页上点击后出现绿色框。 其实重要的是捋清楚网页结构，搞清除哪些是文本，哪些是链接，哪些是元素，爬虫就很简单了。 1）点击网页最下面的蓝色按钮Add new selector创建一个选择器，Id设置为elemment-box,Type设置为Element, 2）点击Selector后面的Select按钮，鼠标移动到网页中，定位到币种列表下第一项BTC-比特币最右边，是不是出现个绿色框，当如下图所示状态时，代表已经选中此行，点击，第一行变红，继续点击下一行，所有行都变成红色就可以了。 3）点击Done selecting!确认选中目标，字段会自动填充到Selector后面的文本框中 4）勾选上Multiple,最后点击Save selector保存，这样我们的一个选择器就创建成功了。 想想为什么我们创建一个类型为元素的选择器，其实看看网页结构就清楚了，我们要抓取的数据都包裹在一个个容器中，我们需要先抓取容器，共50行，下面抓取每一行内容。 5）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name,Type为Text，当点击选择按钮后，选择名称下面的容器，别选择容器内文本，确认后面字段为span.mgl10,不需要选择multiple,直接Save selector就可以了 6）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为num,Type为Text，当点击选择按钮后，选择#下面的容器，别选择容器内文本，确认后面字段为div.col-md-1.col-xs-1,不需要选择multiple,直接Save selector就可以了 7）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name-link,Type为Link，当点击选择按钮后，选择名称下面的容器，确认后面字段为div.col-md-3 a,不需要选择multiple,直接Save selector就可以了 至此，父页面设置好了，下面我们抓取子页面的内容 8）点击BTC-比特币的链接，进入子页面，然后进入name-link目录，在此目录下分别创建web,amout,resum，whitepaper,四个选择集 9）web选择集设置Type为Text，Selector后面字段为p.col-sm-4:nth-of-type(1) a 10）amout选择集设置Type为Text，Selector后面字段为div.col-xs-6 p.num 11）resum选择集设置Type为Text，Selector后面字段为p.break-line-4 12）whitepaper选择集设置Type为Link,Selector后面字段为p.col-sm-4:nth-of-type(6) a 3.3 抓取数据完成上面的设置后，点击Sitemap block的下拉菜单选择scrape,保持延迟为默认2000，点击蓝色按钮Start scraping就开始抓取数据了. 4. 导出数据4.1 导出到Excel表格抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 4.2 对数据进行筛选从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言系列（二）]]></title>
    <url>%2F2018%2F01%2F31%2Fgo3%2F</url>
    <content type="text"><![CDATA[Ubuntu操作系统安装配置假设你的电脑是mac电脑，先下载ubuntu-16.04.3-desktop-amd64安装包到本地,并且下载一个虚拟机VirtualBox-5.2.4-119785-OSX。 1. 安装ubuntu操作系统按照次序安装，先安装VirtualBox,安装后运行，在 Oracle VM VirtualBox Manager主界面选择New创建一个Name为Yourname,Type为Linux,Version为Ubuntu(64-bit)后选择蓝色按钮Continue进入下一界面，设置Memory size为默认，继续下一步，设置File location and size为20G到50G之间就可以。 2. 配置虚拟机ubuntu]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言系列（一）]]></title>
    <url>%2F2018%2F01%2F31%2Fgo2%2F</url>
    <content type="text"><![CDATA[学习教程关键字：管道，同步，异步，缓冲管道，非缓冲管道，死锁 1. 创建管道1c := make(chan int, 1)//创建一个管道 2. 读写数据12c &lt;- 10 //写入数据，这条管道只能写入int类型&lt;-c //从管道里面取值 3. 同步和异步1a, ok := &lt;-c //同步 4. 缓冲管道和非缓冲管道12c := make(chan int) //非缓冲管道c := make(chan int，10) //缓冲管道 5. 管道的长度和容量管道遵循先进先出的阵列原则。12len()cap() 6. 管道的作用1管道是多个线程之间传递数据和同步数据的重要手段。 7. 管道操作关闭管道可以用下面命令1close(c) 8. 死锁我们知道管道有长度和容量，数据进入管道后，就可以按照顺序读取出来，假如管道中无数据，那读取的是一个空管道，这时候会发生什么，请看下面完整案例12345678910111213141516171819202122232425262728293031import ( &quot;fmt&quot;)func main() &#123; c := make(chan int) done := make(chan bool) go func() &#123; for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; done &lt;- true &#125;() go func() &#123; for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; done &lt;- true &#125;() &lt;-done //死锁 &lt;-done close(c) for n := range c &#123; fmt.Println(n) &#125;&#125; 9. 管道检测123for n := range c &#123; fmt.Println(n)&#125; 10. 深刻理解 开关 //动作 读写 //动作 生产者 //对象 消费者 //对象 11. 人机对话用机器类比跑一下用人类比跑一下]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[孔壹学院区块链培训课程大纲-解读]]></title>
    <url>%2F2018%2F01%2F30%2Fgo1%2F</url>
    <content type="text"><![CDATA[课程大纲上面是春哥的区块链工程师学习路线图，对区块链不甚了解的朋友，看此路线图大概会有一个概念。 1. 解读之前工欲善其事必先利其器，同样道理，区块链开发应先选择一种利器，这就是go语言。 如果用精美的盒子类比区块链，盒子中的美玉可类比智能合约代币。 区块链其实很早就已经存在于人类历史中，只是换了一种说法，人话换成了计算机语言。 2. Go语言说到了计算机语言，和人类语言模式几乎一样，反而人类语言比计算机语言复杂许多，计算机只有0和1，人类还有26个字母。 1） go语言基础语言需要环境，go语言运行的环境，建议的是linux操作系统-ubutungo语言的基本语法，分别是变量，常量，类型和函数，学过计算机编程语言的可能比较熟悉。 2） 常用算法算法是什么那，就是计算机处理数据的方法，数据从你那到我这里可以直着走，也可以绕圈走。如果数据直走，人很容易理解，线性思维考验的是人的逻辑。如果数据绕圈走，人很容易陷入尴尬，形象点的形容为“蒙圈”。 3） go语言高级编程面向对象编程并发编程网络编程工程管理 3. React3.1. Html+css+js 网站设计三“贱”客3.2. ES6 前端js规范3.3. react 前端框架3.4. Flux 是Web应用的前端架构3.5. Redux 是JS状态容器，前面很简单,忙烦的是后面 4. SoliditySolidity是一种语法类似JavaScript的高级语言1） 智能合约介绍2） 安装Solidity3） Solidity 编程实例 5. 密码学还没学，暂时不解读了。 6. 共识算法还没学，暂时不解读了。 7. 超级账本还没学，暂时不解读了。 8. 比特币源码分析还没学，暂时不解读了。 9. 实际项目-开发一条链 提出需求，解决问题 想像空间很大 10. 总结区块链学习之路：路漫漫其修远兮，吾将上下而求索。也就是不失时机地去寻求正确方法以解决面临问题]]></content>
      <categories>
        <category>学习大纲</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用框架Hexo在Github上搭建个人博客]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo+Github [Mac环境] 假如你有一个Github帐号，我们就可以开始了，如果你说没有，就去注册好了。想想咱们注册微信时也不是很难的事吧，准备好一个邮箱就行了，真的别的都不需要。 1. 配置远程和本地Github1.1 在 Github 上创建一个仓库（Repo）登陆Github网址，用你的账号登陆进去，点右上角的+，弹出菜单选择New repository,在弹出的Repository name下面的文本框内按照yourname.github.io 这种格式输入，然后选中 Public, 最后点击绿色的Create repository创建成功。 重新登陆，点右上角你的头像，在弹出的菜单中选中Your profile,会发现“youname.github.io”分支创建成功，点击进去，在右边找到Settings,在左侧栏最下面找到Deploy keys,点击Add deploy key,输入你的”key”,密匙的求解过程请参见Git密匙,至此你的远程仓库部分已经配置完成。 如果你对git很感兴趣，或者，对git的命令行方式很头疼的，可以阅读此物: Git入门教材 ⚠️我的git仓库名字为zhaodongchun.github.io,你的就用你自己的名字好了. 1.2 确认本地已经安装好 git 和 npm在终端输入下面两条命令，确认已经安装好git和npm,如果电脑还没装这两个东西的，请参照官方文档安装：Git入门教材+npm中文文档 12git --versionnpm --version 2. 配置Hexo 1） 安装 hexo 先通读官方文档hexo自动部署网站,不需要看内容，快速翻一遍知道有这个工具在这里就可以了，以后需要时再调用它。然后终端输入以下命令12npm install hexo -gnpm install hexo-cli -g 2） 创建本地工作目录 先登陆到github，点击你的分支yourname.github.io,在右边有个绿色的按钮Clone or download,点开后点击copy to clipboard把自己的git地址拷贝出来，在终端cd到你希望把站点放置的位置，下面我cd到Desktop了 12cd ~/Desktopgit clone https://github.com/zhaodongchun/zhaodongchun.github.io.git 3）初始化你的本地站点 12345hexo init yourname.github.iocd yourname.github.ionpm install hexo-deployer-git --savehexo generatehexo server 在终端打完以上命令后，如果最后显示Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了，需要注意的是这个效果是hexo默认模版landscape的效果，下面我们学学怎么更换模版为Next模版。 4）设置个人模版 这里涉及两个东西，一个是Hexo,一个是Next,我们先到Hexo模版，先看看都有哪些模版可供我们选择，如果你点击模版下面的大标题名字后会进入到github的源文件地址，和创建本地工作目录一样，可以把它的Git地址拷贝出来。先以next模版为例，先定位到Hexo站点目录下，在终端输入以下命令安装 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，修改配置文件_config.yml中的 theme 字段为 next后保存，至此我们完成了站点配置。在终端继续输入以下命令完成模版调试，如果再此出现Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了 1hexo server --debug 5） 使用Atom码文章 先把Atom下载下来，官网直接下载安装或在终端输入下面命令也可以，如果对Atom还不熟悉没关系，先从官方文档开始逐渐建立Atom语法吧，在线阅读:飞行手册 给 Atom 安装一个命令行面板，Atom 里同时按command+，调出setting面板，定位到install选项，在文本框中搜索platformio-ide-terminal后点击install安装atom包，安装完成后按command+shift+t在下面会出现一个终端，这个包的作用就是解决总是来回切换atom和终端的问题。 完成上面的操作后，我们对包大概有了个概念，下面继续安装一个markdown包，点击Atom菜单下的Preference的左侧倒数第二项+ install，输入markdown，依次安装几个包 markdown-scroll-synclinter-markdownmarkdown-writermarkdown-tocmarkdown-pdfmarkdown-preview 然后就是随便折腾一会，看看这几个都实现什么功能，接下来用markdown书写文章的过程中会经常使用这几个包/Desktop/zhaodongchun.github.io/zhaodongchun.github.io,这是我的目前位置，你可以在mac终端输入ls查看你是否在根路径下，然后终端输入atom .在atom中打开所有文件，然后使用快捷键command+shift+t打开atom终端，mac的终端就可以关闭了，在左侧栏定位到source文件夹下的_posts文件夹，展开后有一个hello-world.md文件，这个文件就是网站上看到的源文件。我们用一下刚才掌握的几个快捷键试试 command+w 关闭当前标签command+shift+m 终端ctrl+shift+m 预览 “&gt;” 块引用 “-” 任务列表“0.” 有序列表 快捷键熟悉差多了，再回去翻翻Next模版，设置下站点配置文件和主题配置文件，设置语言和你的昵称，基本上博客就可以了，保存后在终端输入下面调试命令,如果再此出现Database saved，代表本地站点已经初始化完成，可以在浏览器输入http://localhost:4000/查看你的站点了。 1hexo server --debug 3. 部署到 Github 上把本地文件上传到github远程前，我们需要告诉atom上传到的路径，先登陆github，进入zhaodongchun.github.io这个分支，点击绿色的clone or download按钮拷贝出来路径，再进入atom，左侧根目录会有一个_config.yml文件，下面我们设置下这个配置文件，先把拷贝出来的路径粘贴到url后面，注意截止到/,将root后面改成你的github上的仓库一样，repo后面的直接把你拷贝出来的粘贴就行了，注意:后面的空格不要少，这样atom就知道上传给谁了。 url: https://github.com/konglongyinger/zhaodongchun.github.io/ root: /zhaodongchun.github.io deploy: type: git repo: https://github.com/konglongyinger/zhaodongchun.github.io.git 修改完成后保存，在atom终端输入下面命令，在github上查看上传结果，如果发现文件已经显示，就可以进入github你的分支下的settings，往下翻找到GitHub Pages这里，将source下的None改为master branch,点击保存后，会出现绿色的一条提示Your site is published at https://konglongyinger.github.io/zhaodongchun.github.io/，后面链接就是你的网址了，现在你可以点击看看效果。 1hexo deploy 4. 调试网站 如果每次在本地修改文章，可以用下面命令调试预览 1hexo s --debug 如果改动了配置文件，在上传到github前最好使用清理命令，清除public目录 1hexo clean 如果完成阶段性任务了可以用下面命令上传到github 1hexo deploy 5. 域名绑定首先你的有个域名，举例来说我是从百度买的，有了域名后再分三步走。 1） 配置CNAME 在hexo文件夹下的source中新建一个文本文档， 里边输入刚才我们买到的域名的二级域名。举例来说，我申请的是zhaodongchun.com，就填写zhaodongchun.com,然后保存为CNAME.注意大写的CNAME. 2） 配置解析服务器 接下来进域名服务商的后台进行域名解析设置,添加CNAME记录类型，解析线路默认就好了，记录值为zhaodongchun.github.io,配置好后我们本地重新上传到github。 3） 配置站点设置文件重定向 还记得我们没有绑定域名之前设置的配置文件吗，绑定域名后需要重新设置下url和root,否则css有可能会丢失，将其设置回默认，如下设置： url: https://zhaodongchun.comroot: / 4）好，到此为止，重新执行下面命令将文件上传到github，浏览器输入你的域名就可以正常登陆了。 123hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
