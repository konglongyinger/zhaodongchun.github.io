<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[什么是六体]]></title>
    <url>%2F2018%2F07%2F04%2F6ti1%2F</url>
    <content type="text"><![CDATA[给六体人一个身份，给未来一个广角镜头。 刘慈欣创作的系列长篇科幻小说《三体》，很多人读过，故事讲述的地球人类文明和三体文明的信息交流、生死搏杀及两个文明在宇宙中的兴衰历程。 当2008年一场先源于美国、后蔓延全球的金融危机时，中本聪在网络上发表一篇论文《一种点对点的电子现金系统》。因此必然性的发明了比特币。 时间在十年后的2018年，这两个事件又导火索般的产生了六体。 1. 什么是六体如果用一句话解释下什么是六体，如下所述： 六体是一个最小化的人际协作系统。 如果想深入理解六体，需要理解第一个概念：人类协作 人类社会的本质是分工协作（亚当.密斯《国富论》）。 我们知道在历史长河中，人类刚开始是不会协作的，后来才逐渐发展为群居动物的，原始社会时期分工协作局限在部落内部，且仅仅局限在物物交换，后来随着生产力的发展，并且掌握了火这种工具，参与交换的品类和频率逐渐增多，人们发明了一般等价物这种商品，我国最早充当一般等价物的的商品之一是贝，后来因金银的种种优点，充当了固定一般等价物，发展成了货币。 货币的出现是一个划时代的出现。货币是人类社会分工协作的润滑剂，没有货币，现代人类社会大规模的分工协作就无法顺利进行。自从货币出现后，人们分工协作的规模和深度得到空前的发展，货币也经历了贵金属到纸币的发展历程。 如果一个分工协作体系内，足够大比例的人感到参与原有分工协作无利可图，那么他们必将退出或部分退出（失业或部分失业），那么原有的分工协作结构就难以为继，经济社会必然就要出现结构的调整，这就是危机。经济危机（或社会危机）的本质就是旧有的分工协作体系难以为继，分工协作体系的结构出现调整。 在中国，一切社会经济问题的根源在于社会各集团的实力太不均衡。政府之所以对经济系统进行干预，本身就是受不同利益集团支配的结果，因此任何政府之所以能够干预经济，本身是各社会集团实力对比的结果，在实力对比不均衡的情况下，政府干预经济不可避免。 站在国家治理的角度来讲，所谓的产业优化，本质上是只能做到对已产生的利益集团的均衡，无法从根源上优化人类分工协作的原始结构。正如《圣经》所言，太阳底下没有新鲜事，过去有的，今天也有，将来仍然会有。 既然自上而下的治理无法根本上解决经济的问题，我们可以试试自下而上的治理，重新优化我们的协作方式为秩序的，重新优化我们的货币系统为可信的。 幸运的是我们站在了历史的转折点，2018年区块链技术迅速发展，全球经济也在一个停滞不前的状态。运用区块链技术陌生人之间的信任问题得以解决，和陌生人交易从来没有像今天这样方便，无需信任，无需等待。 建议大家有时间读一读马特·里德利所著的《美德的起源》，本书对人类信任与美德进行了饶有趣味的研究，并向我们展示了近年来相关的研究成果——个体私欲与互助并非绝不相容。 六体要做的就是一个最小化的人际协作模型，在此小世界中人们优化了协作流程和效率，人和人之间无需信任，交易实时可信，人人互助互利，个体属于这个系统，系统离不开个体。 2.六体人长什么样？如果我们理解了六体，接下来的逻辑就是需要了解六体里的人都是什么样的？ 六体人都有一个能量环在头顶： 接下来的问题可能就是：为什么要有这么一个能量环，他象征着什么？ 能量环代表着时间和精力的总和，满环代表这个人有充足的时间和精力，他可以接受接下来的很多任务。空环代表着这个人已经没有充足的时间和精力，如果有接下来的任务就需要等待了。 接下来的问题是为什么要设计这么一个环？ 其实这个环不是让自己看的，是用来给其他的六体人看的，还记得协作的概念吗，人和人之间不可能孤立的存在，几乎每天都要涉及到协作，为了和其他的六体人更好的协作，设置了一个状态坞，即是对他人协作的信号也是对自己隐私的保护。 当某个六体人很疲惫的想快乐休息的时候，用积累的装备来升级自定义自己的状态坞，定为空就可以了，这样所有人就都知道：他想独自享受一下存在美了。 3.六体的功能在六体中主要的构成是人，所以我们的实验始终围绕人性，在系统中将人分为六种人格，这六种人格的人会在不同的时间处于不同的事件中，对于每一个事件我们都可以归纳为是为了完成某种功能。不管此人的兴趣和爱好使然还是被动的受事件所迫。 我们参考了霍兰德以自⼰的职业咨询经验为基础提出的一种关于职业选择的人格类型理论，此理论将人格性向和职业类型划分的六种，具体内容如下:现实型，研究型，艺术型，社会型，企业家型，传统型。 现实型 1234人格特点:愿意使用工具从事操作性强的工作；动手能力强，做事手脚灵活，动作协调；不善言辞，不善交际。职业类型:各类工程技术工作、农业工作；通常需要一定体力，需要运用工具或操作机械。主要职业：工程师、技术员；机械操作、维修安装工人、木工、电工、鞋匠等；司机；测绘员、描图员；农民、牧民、渔民等。 研究型 1234人格特点:抽象能力强，求知欲强，肯动脑筋，善思考，不愿动手；喜欢独立和富有创造性的工作；知识渊博，有学识才能，不善于领导他人职业类型:主要指科学研究和科学实验工作。主要职业：自然科学和社会科学方面的研究人员、专家；化学、冶金、电子、无线电、电视、飞机等方面的工程师、技术人员；飞行驾驶员、计算机操作人员等。 艺术型 1234人格特点:喜欢以各种艺术形式的创作来表现自己的才能，实现自身价值；具有特殊艺术才能和个性；乐于创造新颖的、与众不同的艺术成果、渴望表现自己的个性。职业类型:主要指各种艺术创造工作。主要职业：音乐、舞蹈、戏剧等方面的演员、艺术家编导、教师；文学、艺术方面的评论员；广播节目的主持人、编辑、作者；绘图、书法、摄影家；艺术、家具、珠宝、房屋装饰等行业的设计师等 社会型 1234人格特点:喜欢从事为他人服务和教育他人的工作；喜欢参与解决人们共同关心的社会问题，渴望发挥自己的社会作用；比较看重社会义务和社会道德职业类型:主要指各种直接为他人服务得工作，如医疗服务、教育服务、生活服务等。主要职业：教师，保育员、行政人员；医护人员；衣食住行服务行业得经理、管理人员和服务人员；福利人员等。 企业家型 1234人格特点:精力充沛、自信、善交际，具有领导才能；喜欢竞争，敢冒风险；喜欢权力、地位和物质财富职业类型:主要指那些组织与影响他人共同完成组织目标的工作。主要职业：经历企业家、政府官员、商人、行政部门和单位的领导者、管理者 传统型 1234人格特点:喜欢按计划办事，习惯接受他人的智慧和领导，自己不谋求领导职位；不喜欢冒险和竞争；工作踏实、忠诚可靠，遵守纪律职业类型:主要指各类文件档案、图书资料、统计报表之类相关的各类科室工作。主要职业：会计、出纳、统计人员；打字员；办公室人员；秘书和文书。图书管理员；旅游、外贸职员，保管员，邮递员，审计人员，人事职员等. 在日常生产生活中，我们无时无刻不处于某个事件中，运气好的话，处于好的一个事件，运气差的话处于一个坏的事件，如果你是二战时期的犹太人，有可能处于《希德勒的名单》的某个悲惨事件中，如果你是二战时期的中国人，就有可能处于《南京大屠杀》的某个悲催事件中。 我们参考了现代社会发展出来的群体协作方式即公司制度，抽象出来六种功能： 技术，产品，市场，投资，设计，品牌 技术 1234在公司制度体系下：某项技术都是服务于某个产品，通过产品去占领市场用的。在自治制度体系内：我们的技术用于研发高效的协作工具，这些工具是为某些产品服务的。 产品 1234在公司制度体系下：某个产品是某一领域的用户所需求的，这些产品需要用户花费金钱去购买，为满足人的生产生活所需。在自治制度体系内：我们的产品是为了满足某个行业的个性化发展而出的一系列解决方案，这些产品的目的就是保证整个生态体系的可持续发展。 市场 1234在公司制度体系下：市场是用来扩大规模，运用推广和营销手段，不断扩大用户群体，带来不断增加的现金流。在自治制度体系内：市场也是用来扩张，只是六体扩张的是不断高效的分工协作网络，随着六体人的不断增多，社会越来越有序和谐发展。 设计 1234在公司制度体系下：设计是为了产品，设计是为了品牌形象，设计是为了更好的治理一个中心化的公司制度。在自治制度体系内：设计不仅仅是为了产品和品牌，多了一个另外一个涵义：服务 品牌 1234在公司制度体系下：品牌是为了营造一种氛围：社会很和谐，我们很健康在自治制度体系内：品牌是为了给社会一种共识，为了更快的让人们达成这种共识。 投资 1234在公司制度体系下：投资的目的就是垄断，垄断的目的就是索取。在自治制度体系内：投资是维持分工协作的必要手段，是维持结构体稳定的必须品。 全部六个功能完备的情况下，会是一个健康可持续发展的六体模型，每一个人会来回穿梭于不同的功能至上，人格魅力会体现在每一个结构面上。 4.六体的概貌如果我们拉长镜头去观察整个模型，会有一副形象化的场景： 一个螺旋桨之上的弹簧模型，随着螺旋桨的不断转动，弹簧之上的生态圈不断上升，随着螺旋桨的不断减速，弹簧之上的生态圈不断下降。 有风和无风是一个随机事件，不断刺激着构建在螺旋桨之上的各行各业的生态建设。 就像中国的阴阳学说，有虚有实。 虚是一种缓存，是为了明天的实；实是一种满足，是为了明天的虚。 5.六体的价值六体存在的价值，主要体现在三方面： 链接价值 服务价值 社会价值 就像互联网是搭建在超链接之上，价值互联网也是搭建在价值链接之上。]]></content>
      <categories>
        <category>六体</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发07-学会使用IDE创建智能合约]]></title>
    <url>%2F2018%2F04%2F25%2Feos7%2F</url>
    <content type="text"><![CDATA[上面几篇我们是通过下载源码，建立目录，生成ABI的方式创建智能合约。 但是实际项目开发中，我们使用IDE（集成开发环境）这种方式。 本章介绍如何使用CLion IDE设置EOS合约开发环境。 1. 下载CLion下载地址 2. 下载模版安装CLion之前，我们先下载一个EOS示例项目“eos-clion-example”，以便CLion安装好后直接导入.1git clone https://github.com/ukarlsson/eos-clion-example 目录结构如下： 3. 安装CLion1) 找到下载的CLion安装包，双击，拖动安装。 2）选择默认按钮，到激活界面，选择试用版 3）选择默认按钮，设置风格 4）选择默认按钮，导入项目 5）导入后效果]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发06-创建eos多节点网络]]></title>
    <url>%2F2018%2F04%2F23%2Feos6%2F</url>
    <content type="text"><![CDATA[从02到05篇章我们一直是在本地单节点网络中创建钱包，智能合约。 这篇文章将创建一个多节点单主机的网络，实现两个节点间的通信。 1. 多节点网络概念 一个节点占用一个端口，如果想启动多节点需要使用多个端口 一个节点需要一个账户，如果想启动多节点需要使用多个账户 2. 启动第一个节点开启第一个终端，启动节点，此节点是默认的“eosio”账户，又称为“bios 生产者”。 1nodeos 3. 启动第二个节点1）确认已经设置好钱包API插件文件config.ini 2）启动新节点 12cd ~/eos/build/contracts/eosio.biosnodeos -p leo --plugin eosio::chain_api_plugin --plugin eosio::net_api_plugin --http-server-address 127.0.0.1:8889 --p2p-listen-endpoint 127.0.0.1:9877 --p2p-peer-address 127.0.0.1:9876 --config-dir node2 --data-dir node2 --private-key [\"EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8\",\"5JM8oznp4ssuTvgFEzj2C98MzkitF64g5NGPTmGu3LdYqXsiJT2\"] 如上图所示，第一个节点在产生区块（generate block），第二节点只是同步区块（push block） 可以看出我们使用03篇创建好的“leo”账户来启动的新节点，”leo”账户owner权限的公私匙请查看03篇。 3) 设置节点2 1cleos push action eosio setprods &quot;&#123; \&quot;version\&quot;: 1, \&quot;producers\&quot;: [&#123;\&quot;producer_name\&quot;: \&quot;leo\&quot;,\&quot;block_signing_key\&quot;: \&quot;EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8\&quot;&#125;]&#125;&quot; -p eosio@active 通过设置节点，我们将账户为“leo”的第二个节点转变为活跃的生产者。 查看两个运行节点的终端，结果是第一个节点不再生成（generated）区块，变成接收(push)区块并同步；第二个节点不再接收（push）区块并同步，变成生成(generated)区块。 4.获取节点信息1）第一个节点 1cleos --port 8888 get info 结果如下： 12345678&#123; &quot;server_version&quot;: &quot;7b28e59c&quot;, &quot;head_block_num&quot;: 51799, &quot;last_irreversible_block_num&quot;: 51798, &quot;head_block_id&quot;: &quot;0000ca57dbeff449459c61de62486508241e74771e14aa73170db0d3f153c432&quot;, &quot;head_block_time&quot;: &quot;2018-04-24T06:33:52&quot;, &quot;head_block_producer&quot;: &quot;leo&quot;&#125; 2）第二个节点 1cleos --port 8889 get info 结果如下： 12345678&#123; &quot;server_version&quot;: &quot;7b28e59c&quot;, &quot;head_block_num&quot;: 51918, &quot;last_irreversible_block_num&quot;: 51917, &quot;head_block_id&quot;: &quot;0000cace679045d94d6953eac5c2631326f96cfdfc85aaf91cf2064b894b96af&quot;, &quot;head_block_time&quot;: &quot;2018-04-24T06:34:51&quot;, &quot;head_block_producer&quot;: &quot;leo&quot;&#125; 5. 节点重置如何恢复多节点网络到单节点网络，其实不需要重新编译，只需要删除区块链节点数据，配置做下更改即可。 1）在/Library/Application Support/eosio/nodeos/data目录下，将default.wallet文件拷贝出来。 2）定位到Library/Application Support/目录,删除eosio文件夹。 3）定位到Library/Application Support/eosio/nodeos/config目录,打开config.ini文件,通过#标记删除账户历史。1# plugin = eosio::account_history_api_plugin 4） 运行节点1nodeos 重置成功，区块链单节点启动。]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发05-创建eos智能合约-currency]]></title>
    <url>%2F2018%2F04%2F19%2Feos5%2F</url>
    <content type="text"><![CDATA[03篇我们创建了一个EOS钱包，我们用这个钱包default创建另一个currency账户。 请保持区块链一直运行状态。 1. 查看钱包123cleos wallet opencleos wallet unlockcleos wallet list 2. 创建currency账户1cleos create account eosio currency EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8 EOS7s4cAmYBWbA5GFSDUXyepSgWYDm9CabBNxjAyuNDTJ3wGe9tvN 3. 查看账户信息1cleos get account currency 4. 部署合约1)检查合约的ABI编码1cleos get code currency 结果为0,见下：1code hash: 0000000000000000000000000000000000000000000000000000000000000000 2)使用账户“currency”部署智能合约,运行指令：1cleos set contract currency ../../contracts/currency 结果如下：123456Reading WAST/WASM from ../../contracts/currency/currency.wast...Assembling WASM...Publishing contract...executed transaction: 385973aa8d4aaecb8988ec56ab3704ad96afc5df3c1daa184a14bd198f5a7345 7136 bytes 2200576 cycles# eosio &lt;= eosio::setcode &#123;&quot;account&quot;:&quot;currency&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d010000000189011660000060027e7e0060017...# eosio &lt;= eosio::setabi &#123;&quot;account&quot;:&quot;currency&quot;,&quot;abi&quot;:&#123;&quot;types&quot;:[&#123;&quot;new_type_name&quot;:&quot;account_name&quot;,&quot;type&quot;:&quot;name&quot;&#125;],&quot;structs&quot;:[&#123;&quot;n... 3)再次检查合约的ABI编码1cleos get code currency 结果如下：1code hash: c5dd1da42fd91751ce1af10b49dc7d65bcf42571e2ca5b18c512707fd385d634 不为0代表部署成功。 5. 创建代币(create)1cleos push action currency create &apos;&#123;&quot;issuer&quot;:&quot;currency&quot;,&quot;maximum_supply&quot;:&quot;100000000.0000 CANDY&quot;,&quot;can_freeze&quot;:&quot;0&quot;,&quot;can_recall&quot;:&quot;0&quot;,&quot;can_whitelist&quot;:&quot;0&quot;&#125;&apos; -p currency@active 这里我们创建了一个叫CANDY的代币，总量为100000000.0000 6. 发行代币(issue)1cleos push action currency issue &apos;&#123;&quot;to&quot;:&quot;currency&quot;,&quot;quantity&quot;:&quot;1000000.0000 CANDY&quot;,&quot;memo&quot;:&quot;&quot;&#125;&apos; -p currency@active 这里发行了100万个CANDY，并发送给了currency账户 7. 转账（transfer）1cleos push action currency transfer &apos;&#123;&quot;from&quot;:&quot;currency&quot;,&quot;to&quot;:&quot;leo&quot;,&quot;quantity&quot;:&quot;888.0000 CANDY&quot;,&quot;memo&quot;:&quot;transfer 888 CANDY to leo&quot;&#125;&apos; -p currency@active 这里我们给一个叫leo账户的转账了888.0000CANDY.memo为备忘录,是自定义内容。 8. 查看账户余额12cleos get table currency currency accountscleos get table currency leo accounts]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发04-创建eos智能合约-hello world]]></title>
    <url>%2F2018%2F04%2F18%2Feos4%2F</url>
    <content type="text"><![CDATA[上篇我们创建了一个EOS钱包，有了钱包我们可以用这个钱包创建一个账户。 请保持区块链一直运行状态。 1. 创建合约定位到eos/build/contracts/目录,新建一个“helloworld”目录,此目录下新建一个“helloworld.cpp”文件.1234cd contractsmkdir helloworldcd helloworldtouch helloworld.cpp 复制下面合约代码到文件中：123456789101112131415#include &lt;eosiolib/eosio.hpp&gt; #include &lt;eosiolib/print.hpp&gt;using namespace eosio; class helloeos : public eosio::contract &#123; public: using contract::contract; void hello(account_name user) &#123; print("Hello world! ", name&#123;user&#125;); &#125; &#125;; EOSIO_ABI(helloeos, (hello)) 2. 编译合约在终端通过eosiocpp命令，生成wast和abi文件 1）编译成wast文件1eosiocpp -o helloworld.wast helloworld.cpp 2）编译成abi文件 1eosiocpp -g helloworld.abi helloworld.cpp 结果目录如下： 3. 部署合约定位到eos/build/contracts/helloworld/目录，使用PW5KTy4QS1vkCtRev1dAgMYRAm8m5x1BncU52CEj2R2Z119YvzZHv解锁钱包，使用账号“leo”部署智能合约,运行指令：1234cd helloworldcleos wallet opencleos wallet unlockcleos set contract leo ../helloworld -p leo 4. 调用合约定位到eos/build/contracts/helloworld/目录，使用push action命令调用合约：1cleos push action leo hello '[leo]' -p leo 智能合约调用成功！ 在部署和调用合约成功后，区块链上也会有相关记录。 通过操作我们知道了EOS智能合约是C++编写的一段程序，智能合约和区块链关系就像寄生。]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发03-创建eos钱包]]></title>
    <url>%2F2018%2F04%2F18%2Feos3%2F</url>
    <content type="text"><![CDATA[上篇我们启动了EOS区块链，请保持区块链一直运行状态。 先思考一个问题：钱包和区块链是什么关系？ 再思考另外一个问题：智能合约和区块链是什么关系？ 让我们带着疑问继续下面的学习。 1. 创建钱包运行cleos指令：1cleos wallet create 终端显示以下结果： 1234Creating wallet: defaultSave password to use in the future to unlock this wallet.Without password imported keys will not be retrievable.&quot;PW5KTy4QS1vkCtRev1dAgMYRAm8m5x1BncU52CEj2R2Z119YvzZHv&quot; 1）如下目录得到一个default.wallet的文件： 2）区块链网络中相应会多出一条记录： 通过创建钱包，我们知道了区块链发生什么。明白了钱包是写入区块链上的一段程序. 2. 获取公匙/私匙1）打开钱包 1cleos wallet open 2）查看打开的钱包列表1cleos wallet list 3）解锁钱包1cleos wallet unlock password后面粘贴钱包密码：PW5KTy4QS1vkCtRev1dAgMYRAm8m5x1BncU52CEj2R2Z119YvzZHv，解锁。 4）获取公匙/私匙1cleos wallet keys 终端显示以下结果：12345[[ &quot;EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV&quot;, &quot;5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3&quot; ]] 上面的是公钥，下面的是私钥 3. 创建账户1) 使用公匙查看账户信息1cleos get accounts EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 结果如下：123&#123; &quot;account_names&quot;: []&#125; 2）创建四个密匙 创建第一对公私匙（owner权限）：1cleos create key 结果如下：12Private key: 5JM8oznp4ssuTvgFEzj2C98MzkitF64g5NGPTmGu3LdYqXsiJT2Public key: EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8 创建第二对公私匙：1cleos create key 结果如下：12Private key: 5Jrnt6nQp6Rqu2MCKhdLfX3nD1ZkNDXYYYeESydKbdx9UXnahioPublic key: EOS7s4cAmYBWbA5GFSDUXyepSgWYDm9CabBNxjAyuNDTJ3wGe9tvN 通过上面命令随机生成四个密匙，记住权限为owner的一对公私钥，如果创建多节点需要。 3）导入到钱包 把两个私钥（privateKey）导入到钱包。12cleos wallet import 5JM8oznp4ssuTvgFEzj2C98MzkitF64g5NGPTmGu3LdYqXsiJT2cleos wallet import 5Jrnt6nQp6Rqu2MCKhdLfX3nD1ZkNDXYYYeESydKbdx9UXnahio 4）创建账户1cleos create account eosio leo EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8 EOS7s4cAmYBWbA5GFSDUXyepSgWYDm9CabBNxjAyuNDTJ3wGe9tvN 可以看到，账户创建成功。 其中“leo”是我创建的账户名，“eosio”是创建者（bios 生产者）,EOS7kAFTAwFdurP9cMQJ1zd9akvUDPNhpnWUzUrdpjcf6nGMiQuy8EOS7s4cAmYBWbA5GFSDUXyepSgWYDm9CabBNxjAyuNDTJ3wGe9tvN是两个公匙。 5) 查看账户1cleos get account leo 下篇我们创建一个智能合约，看看智能合约又是什么，智能合约和区块链又是什么关系。]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发02-运行一个eos区块链]]></title>
    <url>%2F2018%2F04%2F18%2Feos2%2F</url>
    <content type="text"><![CDATA[上篇我们学会了怎么下载和编译可执行文件，本篇学会启动区块链 1. 试运行单节点网络定位到eos/build/programs/nodeos目录，执行命令：12cd ~/eos/build/programs/nodeos./nodeos 结果如下： 第一处表示创建了一个nodeos节点文件夹。第二处表示生产者未配置。 在Library/Application Support/目录下会同时生成一个eosio文件夹。此文件夹用来保存区块链节点数据。 接下来设置下配置文件，配置之前ctrl+c先退出网络。 2. 修改配置文件config.ini1）定位到Library/Application Support/eosio/nodeos/config目录,使用vi命令打开config.ini文件：12cd ~/Library/'Application Support'/eosio/nodeos/configvi config.ini 2）配置 先定位到第8行，做以下配置1genesis-json = &quot;/Users/zhaodongchun/Library/Application Support/eosio/nodeos/config/genesis.json&quot; 再定位到第107行，做以下配置 1enable-stale-production = true 最后，在文本底部插入以下代码1234567891011# Enable block production with the testnet producersproducer-name = eosio# Load the block producer plugin, so you can produce blocksplugin = eosio::producer_plugin# Wallet pluginplugin = eosio::wallet_api_plugin# As well as API and HTTP pluginsplugin = eosio::chain_api_pluginplugin = eosio::http_plugin# This will be used by the validation step below, to view account history# plugin = eosio::account_history_api_plugin 3. 运行单节点网络1）终端任意位置运行nodeos指令：1nodeos 至此EOS区块链启动起来了。 2）在不设置配置文件的情况下，终端运行以下指令也可启动单节点网络：1nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::account_history_api_plugin]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EOS(DAWN3.0)智能合约开发01-下载和编译eos工程（2小时）]]></title>
    <url>%2F2018%2F04%2F18%2Feos1%2F</url>
    <content type="text"><![CDATA[此篇文章即开启一个新的系列：EOS智能合约开发。 对于比特币，以太坊的技术相信大家很熟悉了，但是如果想应用于各行各业对性能的要求就很高，希望通过学习此系列课程，将区块链科技彻底融入我们的生活中。 距离EOS最新版本的项目代码(DAWN 3.0)发布已经12天了，此后文档实现完全基于EOS DAWN3.0,以后不再说明。 系统支持见下图,注意官方建议的macOS版本（MacOS 10.13.x）。 1. 下载定位到电脑根目录，终端运行git clone指令：12cd ~git clone https://github.com/eosio/eos --recursive --depth 1 2. 编译编译的简单方法是运行自动化编译脚本。 确认EOS项目的代码完全下载在本地后，终端继续输入命令：12cd eos./eosio_build.sh 以下结果为成功： 编译完成后，在EOS目录下会出现一个build文件夹。]]></content>
      <categories>
        <category>EOS智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[去中心化拍卖项目ebay_Dapp]]></title>
    <url>%2F2018%2F03%2F10%2Fdapp1%2F</url>
    <content type="text"><![CDATA[创建一个去中心化拍卖项目ebay_dapp,实现在以太坊上拍卖商品的功能。 1. 下载项目模版1git clone https://github.com/konglongyinger/Dapp-vote.git 2. 安装相关依赖包1） 安装ipfs-ipfsAPI1npm install ipfs-api 2) 安装node_module文件夹1npm i 3. 安装种子文件seed.js3.1 新建图片和描述信息1）在桌面创建一个data文件夹用来存放图片和描述信息，并且创建一个desc.txt文件用来存储描述信息1234cd desktopmkdir datacd datatouch desc.txt 2）下载一张图片放到data文件夹中，命名为mac,并且编辑desc.txt文件，cat命令后显示以下：1234$ cat desc.txt名称:Power Macintosh（Power Mac）发布时间：1994停产时间：1998 3.2 添加数据到ipfs1) 启动IPFS节点服务1ipfs daemon 2) 添加数据到ipfs123cd dataipfs add desc.txtipfs add mac.jpg 得到图片的哈希值，和描述文件的哈希值。 3.3 配置种子文件1) 新建seed.js文件 atom打开项目12cd ebay_dappatom . 项目根目录下新建文件，命名为seed.js 2) 拷贝以下代码到seed.js文件中 12345678910111213Eutil = require(&apos;ethereumjs-util&apos;);EcommerceStore = artifacts.require(&quot;./EcommerceStore.sol&quot;);module.exports = function(callback) &#123; current_time = Math.round(new Date() / 1000); amt_1 = web3.toWei(1, &apos;ether&apos;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Mac Phones &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 200, 2*amt_1, 0).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Mac Phones &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 400, 3*amt_1, 1).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Mac Phones &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 14, amt_1, 0).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Mac Phones &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 86400, 4*amt_1, 1).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Mac Phones &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 86400, 5*amt_1, 1).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.addProductToStore(&apos;Mac&apos;, &apos;Clothing, Shoes &amp; Accessories&apos;, &apos;QmRaNVNKSUPMcAsDYBYQUdexRhqpi72YusgvL5PB5w1XVv&apos;, &apos;QmfGwUSbWnHDckfwZikjucac7Lg7SuN87Fwtsy9Y322czZ&apos;, current_time, current_time + 86400 + 86400 + 86400, 5*amt_1, 1).then(function(f) &#123;console.log(f)&#125;)&#125;); EcommerceStore.deployed().then(function(i) &#123;i.productIndex.call().then(function(f)&#123;console.log(f)&#125;)&#125;);&#125; 3）将seed.js中的六行hash全部替换为3.2节中的ipfs哈希值。 4. 配置前端和合约代码4.1 App文件夹1) 用以下代码替换到javascripts文件夹下app.js中代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Import the page&apos;s CSS. Webpack will know what to do with it.import &quot;../stylesheets/app.css&quot;;// Import libraries we need.import &#123; default as Web3&#125; from &apos;web3&apos;;import &#123; default as contract &#125; from &apos;truffle-contract&apos;// Import our contract artifacts and turn them into usable abstractions.import EcommerceStoreJSON from &apos;../../build/contracts/EcommerceStore.json&apos;// MetaCoin is our usable abstraction, which we&apos;ll use through the code below.var EcommerceStore = contract(EcommerceStoreJSON);// The following code is simple to show off interacting with your contracts.// As your needs grow you will likely need to change its form and structure.// For application bootstrapping, check out window.addEventListener below.window.App = &#123; start: function() &#123; var self = this; console.log(&quot;start: function()&quot;) EcommerceStore.setProvider(web3.currentProvider); renderStore(); &#125;&#125;;function renderStore() &#123; EcommerceStore.deployed().then(function(i) &#123; console.log(&quot;renderStore()&quot;); i.getProduct.call(1).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); i.getProduct.call(2).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); i.getProduct.call(3).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); i.getProduct.call(4).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); i.getProduct.call(5).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); i.getProduct.call(6).then(function(p) &#123; $(&quot;#product-list&quot;).append(buildProduct(p)); &#125;); &#125;);&#125;function buildProduct(product) &#123; console.log(product[3]); let node = $(&quot;&lt;div/&gt;&quot;); node.addClass(&quot;col-sm-3 text-center col-margin-bottom-1&quot;); node.append(&quot;&lt;img src=&apos;http://localhost:8080/ipfs/&quot; + product[3] + &quot;&apos; width=&apos;150px&apos; /&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[1]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[2]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[5]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[6]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;Ether &quot; + product[7] + &quot;&lt;/div&gt;&quot;); return node;&#125;window.addEventListener(&apos;load&apos;, function() &#123; console.log(&quot;window.addEventListener&quot;) // Checking if Web3 has been injected by the browser (Mist/MetaMask) if (typeof web3 !== &apos;undefined&apos;) &#123; console.warn(&quot;Using web3 detected from external source. If you find that your accounts don&apos;t appear or you have 0 MetaCoin, ensure you&apos;ve configured that source properly. If using MetaMask, see the following link. Feel free to delete this warning. :) http://truffleframework.com/tutorials/truffle-and-metamask&quot;) // Use Mist/MetaMask&apos;s provider window.web3 = new Web3(web3.currentProvider); &#125; else &#123; console.warn(&quot;No web3 detected. Falling back to http://127.0.0.1:9545. You should remove this fallback when you deploy live, as it&apos;s inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask&quot;); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) window.web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://127.0.0.1:9545&quot;)); &#125; App.start();&#125;); 2) 用以下代码替换到stylesheets文件夹下app.css文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148.col-margin-bottom-1 &#123; margin-bottom: 1em;&#125;a &#123; cursor: pointer;&#125;.navbar.main &#123; background: #5f6d7f; color: white;&#125;.navbar.main .list.nav-link &#123; background: #01bf86;&#125;.navbar.main a &#123; color: white;&#125;.navbar ul &#123; list-style: none;&#125;.side-bar.col-sm-2 &#123; margin-left: 1em; border-right: 1px solid #5f6d7f;&#125;#product-list.row &#123; margin-left: 0;&#125;#product-list .row,#product-finalize-list &#123; margin-top: 2em;&#125;.row h2,.categories a,#categories a &#123; color: #5f6d7f;&#125;#product-list a,#product-reveal-list a,#product-list .row &gt; div &#123; color: #01bf86;&#125;.container-fluid .row &#123; margin-left: 0px;&#125;#product-list img,#product-reveal-list img,#product-finalize-list img &#123; width: 150px; height: 150px;&#125;.container-fluid .title &#123; font-size: 1.2em; font-weight: bold; margin-top: 1em;&#125;#product-list .details,.container-fluid .title,#product-finalize-list a &#123; color: #5f6d7f;&#125;.product .details &#123; text-decoration: underline;&#125;.time &#123; font-style: italic;&#125;#product-finalize-list .row &gt; div&#123; color: #e76e6e;&#125;#product-details-page &#123; color: #5f6d7f; background-color: #e9ebef;&#125;#product-details-page h4 &#123; margin-top: 0px; font-size: 20px;&#125;#product-details-page h4.align &#123; margin-left: 15px; font-style: italic;&#125;#product-details-page #product-price &#123; color: #01bf86;&#125;#product-details-page .bid-details,#product-details-page #product-desc &#123; padding: 2em;&#125;#product-details-page #product-image &#123; padding: 2em 1em; /*border: 1px solid #b2bcc8;*/ border-radius: 10px; background-color: white;&#125;#product-details-page h1 &#123; color: #5f6d7f;&#125;#product-details-page h2.product-name &#123; color: #01bf86; margin-top: 0; margin-bottom: 1em /*font-size: 1.5em;*/&#125;#product-details-page #product-auction-end &#123; color: #e76e6e; font-style: italic; font-size: 17px;&#125;#product-details-page #product-reveal &#123; margin-top: 3em;&#125;#product-details-page button.form-submit &#123; background-color: #01bf86; color: white;&#125;#product-details-page #product-desc &#123; padding: 2em;&#125; 3）用以下代码替换掉index.html文件中代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Decentralized Ecommerce Store&lt;/title&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Open+Sans:400,700&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;link href=&apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;h1&gt;Ecommerce Store&lt;/h1&gt; &lt;div&gt;Total Products: &lt;span id=&quot;total-products&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;a href=&quot;&quot; class=&quot;btn btn-primary&quot;&gt;List Item&lt;/a&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-2&quot;&gt; &lt;h2&gt;Categories&lt;/h2&gt; &lt;div id=&quot;categories&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2 class=&quot;text-center&quot;&gt;Products To Buy&lt;/h2&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;row&quot; id=&quot;product-list&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2 class=&quot;text-center&quot;&gt;Products In Reveal Stage&lt;/h2&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;row&quot; id=&quot;product-reveal-list&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4) app文件夹下新建一个product.html文件，拷贝以下代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Decentralized Ecommerce Store&lt;/title&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Open+Sans:400,700&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;link href=&apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;text-center&quot;&gt;Product Details&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot; id=&quot;product-details&quot;&gt; &lt;div style=&quot;display: none;&quot; class=&quot;alert alert-success&quot; id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div id=&quot;product-image&quot;&gt;&lt;/div&gt; &lt;div id=&quot;product-name&quot;&gt;&lt;/div&gt; &lt;div id=&quot;product-auction-end&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-8&quot;&gt; &lt;h3&gt;Start Price: &lt;span id=&quot;product-price&quot;&gt;&lt;/span&gt;&lt;/h3&gt; &lt;form id=&quot;bidding&quot; class=&quot;col-sm-4&quot;&gt; &lt;h4&gt;Your Bid&lt;/h4&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bid-amount&quot;&gt;Enter Bid Amount&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;bid-amount&quot; id=&quot;bid-amount&quot; placeholder=&quot;Amount &gt; Start Price&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;bid-send-amount&quot;&gt;Enter Amount To Send&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;bid-send-amount&quot; id=&quot;bid-send-amount&quot; placeholder=&quot;Amount &gt;= Bid Amount&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;secret-text&quot;&gt;Enter Secret Text&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;secret-text&quot; id=&quot;secret-text&quot; placeholder=&quot;Any random text&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;input type=&quot;hidden&quot; name=&quot;product-id&quot; id=&quot;product-id&quot; /&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit Bid&lt;/button&gt; &lt;/form&gt; &lt;form id=&quot;revealing&quot; class=&quot;col-sm-4&quot;&gt; &lt;h4&gt;Reveal Bid&lt;/h4&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;actual-amount&quot;&gt;Amount You Bid&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;actual-amount&quot; id=&quot;actual-amount&quot; placeholder=&quot;Amount &gt; Start Price&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;reveal-secret-text&quot;&gt;Enter Secret Text&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;reveal-secret-text&quot; id=&quot;reveal-secret-text&quot; placeholder=&quot;Any random text&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;input type=&quot;hidden&quot; name=&quot;product-id&quot; id=&quot;product-id&quot; /&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Reveal Bid&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;product-desc&quot; class=&quot;col-sm-12&quot;&gt; &lt;h2&gt;Product Description&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4.2 contracts文件夹1) 仅保留Migrations.sol文件，删除其他文件，新建一个文件，命名为EcommerceStore.sol拷贝以下代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191pragma solidity ^ 0.4 .17;contract EcommerceStore &#123; struct Bid &#123; address bidder; // 拍卖的人的钱包地址 uint productId; // 产品id uint value; // 拍卖出的价格 bool revealed; // 是否公告 &#125; enum ProductStatus &#123; Open, //拍卖中 Sold, //已经拍卖结束 Unsold // 还没开始拍卖 &#125; enum ProductCondition &#123; New, //新 Used //旧 &#125; // 统计拍卖的产品的数量 uint public productIndex; mapping(address =&gt; mapping(uint =&gt; Product)) stores; mapping(uint =&gt; address) productIdInStore; struct Product &#123; uint id; //产品ID string name; // 产品名字 string category; //产品分类 string imageLink; //产品图片在ipfs上返回回来的hash string descLink; //产品描述信息在ipfs上返回回来的hash uint auctionStartTime; // 拍卖的时间 uint auctionEndTime; // 拍卖结束时间 uint startPrice; // 起始拍卖价格 address highestBidder; // 最高拍卖人的地址 uint highestBid; // 当前的产品公告以后最终统计出来的最高的价格 uint secondHighestBid; // 第二高的人出的拍卖价格 uint totalBids; // 一共多少人来参与拍卖 ProductStatus status; // 产品拍卖的状态 ProductCondition condition; // 产品是新的还是旧的 mapping(address =&gt; mapping(bytes32 =&gt; Bid)) bids; &#125; function EcommerceStore() public &#123; productIndex = 0; //0 &#125; // 添加产品到合约里面 function addProductToStore(string _name, string _category, string _imageLink, string _descLink, uint _auctionStartTime, uint _auctionEndTime, uint _startPrice, uint _productCondition) public &#123; // 断言：判断拍卖结束时间必须大于拍卖起始时间 require(_auctionStartTime &lt; _auctionEndTime); // 每增加一款产品，productIndex，计数器 productIndex += 1; // 创建一个产品的结构体对象 Product memory product = Product(productIndex, _name, _category, _imageLink, _descLink, _auctionStartTime, _auctionEndTime, _startPrice, 0, 0, 0, 0, ProductStatus.Open, ProductCondition(_productCondition)); //存储拍卖的产品的产品的信息 stores[msg.sender][productIndex] = product; // 1 -&gt; 0xf550abc productIdInStore[productIndex] = msg.sender; &#125; // 通过id读取产品的数据信息 function getProduct(uint _productId) view public returns(uint, string, string, string, string, uint, uint, uint, ProductStatus, ProductCondition) &#123; Product memory product = stores[productIdInStore[_productId]][_productId]; return (product.id, product.name, product.category, product.imageLink, product.descLink, product.auctionStartTime, product.auctionEndTime, product.startPrice, product.status, product.condition); &#125; // 投标 function bid(uint _productId, bytes32 _bid) payable public returns(bool) &#123; // 获取产品信息 Product storage product = stores[productIdInStore[_productId]][_productId]; // 当前时间必须大于启始拍卖时间 require(now &gt;= product.auctionStartTime); // 当前时间必须小于结束时间 require(now &lt;= product.auctionEndTime); // msg.value 迷惑别人的价格 require(msg.value &gt; product.startPrice); // mapping (address =&gt; mapping (bytes32 =&gt; Bid)) bids; // &#123;0xf55 -&gt; &#123;0xfadfasfasl: Bid&#125;&#125; // 3 + zhaohui require(product.bids[msg.sender][_bid].bidder == 0); // 存储这一次竞标的人的相关信息 product.bids[msg.sender][_bid] = Bid(msg.sender, _productId, msg.value, false); product.totalBids += 1; // 竞标的次数 return true; &#125; // 30 3 // 公告 // 赵辉 0xF055775eBD516e7419ae486C1d50C682d4170645 3 zhaohui 5 100 // 老麻 0xf17f52151EbEF6C7334FAD080c5704D77216b732 5 laoma 8 100 // yunbo 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 2 yunbo 2.5 // 揭标 产品id，产品id由前端提供 // 对于辉哥和老麻公告来讲，你们需要传入两个值，一个是实际想支付的价格，一个是投标的秘钥 function revealBid(uint _productId, string _amount, string _secret) public &#123; // 获取你投标的产品的结构体信息 Product storage product = stores[productIdInStore[_productId]][_productId]; // 当前时间必须大于产品竞标结束时间 require(now &gt; product.auctionEndTime); // sealedBid 生成一个hash bytes32 sealedBid = sha3(_amount, _secret); // 获取投标人的相关信息 Bid memory bidInfo = product.bids[msg.sender][sealedBid]; require(bidInfo.bidder &gt; 0); // 地址不为空 require(bidInfo.revealed == false); // 现在的状态必须为未公告状态 uint refund; // 判断返回多少钱 // 将_amount转换为uint，3 uint amount = stringToUint(_amount); // bidInfo.value 5 if (bidInfo.value &lt; amount) &#123; // 无效的投标 refund = bidInfo.value; &#125; else &#123; if (address(product.highestBidder) == 0) &#123; product.highestBidder = msg.sender; product.highestBid = amount; product.secondHighestBid = product.startPrice; refund = bidInfo.value - amount; // 5 - 3，2 &#125; else &#123; if (amount &gt; product.highestBid) &#123; // 交换j价钱 product.secondHighestBid = product.highestBid; // 把所有钱返回给辉哥 product.highestBidder.transfer(product.highestBid); // 老大变成老麻 product.highestBidder = msg.sender; // 5 product.highestBid = amount; // 8 - 5 = 3 refund = bidInfo.value - amount; &#125; else if (amount &gt; product.secondHighestBid) &#123; product.secondHighestBid = amount; refund = amount; &#125; else &#123; refund = amount; &#125; &#125; if (refund &gt; 0) &#123; // 退还多余的代币 msg.sender.transfer(refund); // 公告成功 product.bids[msg.sender][sealedBid].revealed = true; &#125; &#125; &#125; // 返回老大和老二的数据信息 function highestBidderInfo(uint _productId) view public returns(address, uint, uint) &#123; Product memory product = stores[productIdInStore[_productId]][_productId]; return (product.highestBidder, product.highestBid, product.secondHighestBid); &#125; // 接收到多少次投标 function totalBids(uint _productId) view public returns(uint) &#123; Product memory product = stores[productIdInStore[_productId]][_productId]; return product.totalBids; &#125; // 将string转换为uint类型 function stringToUint(string s) pure private returns(uint) &#123; bytes memory b = bytes(s); uint result = 0; for (uint i = 0; i &lt; b.length; i++) &#123; if (b[i] &gt;= 48 &amp;&amp; b[i] &lt;= 57) &#123; result = result * 10 + (uint(b[i]) - 48); &#125; &#125; return result; &#125;&#125; 4.3 migration文件夹拷贝以下代码，替换掉2_deploy_contracts.js文件中代码12345var EcommerceStore = artifacts.require(&quot;./EcommerceStore.sol&quot;);module.exports = function(deployer) &#123; deployer.deploy(EcommerceStore);&#125;; 4.4 truffle.js修改truffle.js文件中的port: 7545,为port: 9545, 5. 部署合约1) 删除项目根目录下的build文件夹 2) 启动开发服务器,添加种子数据1234truffle developcompilemigrateexec seed.js 3) 运行测试 5. 测试1npm run dev 浏览器打开http://localhost:8081/ 6. 完善二级页面List Item6.1 前端实现接下来实现点击左上角蓝色List Item按钮，跳转到二级页面List Item。 1)在app文件夹下创建一个list-item.html文件，拷贝以下代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Decentralized Ecommerce Store&lt;/title&gt; &lt;link href=&apos;https://fonts.googleapis.com/css?family=Open+Sans:400,700&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;link href=&apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&apos; rel=&apos;stylesheet&apos; type=&apos;text/css&apos;&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;List an item&lt;/h1&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div style=&quot;display: none;&quot; class=&quot;alert alert-success&quot; id=&quot;msg&quot;&gt;&lt;/div&gt; &lt;form class=&quot;form-horizontal col-sm-5&quot; id=&quot;add-item-to-store&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-name&quot; class=&quot;col-sm-2 control-label&quot;&gt;Name&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;product-name&quot; class=&quot;form-control&quot; id=&quot;product-name&quot; placeholder=&quot;iPhone, Jeans, shoes etc&quot; required=&quot;required&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-description&quot; class=&quot;col-sm-2 control-label&quot;&gt;Description&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;product-description&quot; rows=&quot;8&quot; id=&quot;product-description&quot; placeholder=&quot;Enter detailed product description&quot; required=&quot;required&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-image&quot; class=&quot;col-sm-2 control-label&quot;&gt;Upload product photo&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;product-image&quot; class=&quot;form-control&quot; id=&quot;product-image&quot; required=&quot;required&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-category&quot; class=&quot;col-sm-2 control-label&quot;&gt;Category&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;select class=&quot;form-control&quot; name=&quot;product-category&quot; id=&quot;product-category&quot;&gt; &lt;option&gt;Art&lt;/option&gt; &lt;option&gt;Books&lt;/option&gt; &lt;option&gt;Cameras&lt;/option&gt; &lt;option&gt;Cell Phones &amp; Accessories&lt;/option&gt; &lt;option&gt;Clothing&lt;/option&gt; &lt;option&gt;Coins &amp; Paper Money&lt;/option&gt; &lt;option&gt;Collectibles&lt;/option&gt; &lt;option&gt;Computers/Tablets &amp; Networking&lt;/option&gt; &lt;option&gt;Consumer Electronics&lt;/option&gt; &lt;option&gt;Crafts&lt;/option&gt; &lt;option&gt;DVDs &amp; Movies&lt;/option&gt; &lt;option&gt;Entertainment Memorabilia&lt;/option&gt; &lt;option&gt;Gift Cards &amp; Coupons&lt;/option&gt; &lt;option&gt;Music&lt;/option&gt; &lt;option&gt;Musical Instruments &amp; Gear&lt;/option&gt; &lt;option&gt;Pet Supplies&lt;/option&gt; &lt;option&gt;Pottery &amp; Glass&lt;/option&gt; &lt;option&gt;Sporting Goods&lt;/option&gt; &lt;option&gt;Stamps&lt;/option&gt; &lt;option&gt;Tickets&lt;/option&gt; &lt;option&gt;Toys &amp; Hobbies&lt;/option&gt; &lt;option&gt;Video Games&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-price&quot; class=&quot;col-sm-2 control-label&quot;&gt;Start Price&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;product-price&quot; id=&quot;product-price&quot; required=&quot;required&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-condition&quot; class=&quot;col-sm-2 control-label&quot;&gt;Product Condition&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;select class=&quot;form-control&quot; name=&quot;product-condition&quot; id=&quot;product-condition&quot;&gt; &lt;option value=&quot;1&quot;&gt;New&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;Used&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-price&quot; class=&quot;col-sm-2 control-label&quot;&gt;Auction Start Time&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;datetime-local&quot; class=&quot;form-control&quot; name=&quot;product-auction-start&quot; id=&quot;product-auction-start&quot; required=&quot;required&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;product-price&quot; class=&quot;col-sm-2 control-label&quot;&gt;Days to run the auction&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;select class=&quot;form-control&quot; name=&quot;product-auction-end&quot; id=&quot;product-auction-end&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;option&gt;7&lt;/option&gt; &lt;option&gt;10&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Add Product To Store&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2）在index.html增加一a标签,将链接指向List Item，定位到第14行href=“”双引号内填上文件名list-item.html1&lt;a href=&quot;list-item.html&quot; class=&quot;btn btn-primary&quot;&gt;List Item&lt;/a&gt; 3) 在浏览器端验证，点击按钮是够跳转二级页面 6.2 合约实现点击按钮Add Product To Store实现前端首页增加一子项目。 1）定位到app.js文件中，第18行window.App = {}到function renderStore(),用下面代码替换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251window.App = &#123; start: function() &#123; var self = this; EcommerceStore.setProvider(web3.currentProvider); renderStore(); var reader; $(&quot;#product-image&quot;).change(function(event) &#123; const file = event.target.files[0] reader = new window.FileReader() reader.readAsArrayBuffer(file) &#125;); $(&quot;#add-item-to-store&quot;).submit(function(event) &#123; const req = $(&quot;#add-item-to-store&quot;).serialize(); let params = JSON.parse(&apos;&#123;&quot;&apos; + req.replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g,&apos;&quot;:&quot;&apos;) + &apos;&quot;&#125;&apos;); let decodedParams = &#123;&#125; Object.keys(params).forEach(function(v) &#123; decodedParams[v] = decodeURIComponent(decodeURI(params[v])); &#125;); saveProduct(reader, decodedParams); event.preventDefault(); &#125;); $(&quot;#bidding&quot;).submit(function(event) &#123; $(&quot;#msg&quot;).hide(); let amount = $(&quot;#bid-amount&quot;).val(); let sendAmount = $(&quot;#bid-send-amount&quot;).val(); let secretText = $(&quot;#secret-text&quot;).val(); let sealedBid = &apos;0x&apos; + ethUtil.sha3(web3.toWei(amount, &apos;ether&apos;) + secretText).toString(&apos;hex&apos;); let productId = $(&quot;#product-id&quot;).val(); console.log(sealedBid + &quot; for &quot; + productId); EcommerceStore.deployed().then(function(i) &#123; i.bid(parseInt(productId), sealedBid, &#123;value: web3.toWei(sendAmount), from: web3.eth.accounts[0], gas: 440000&#125;).then( function(f) &#123; $(&quot;#msg&quot;).html(&quot;Your bid has been successfully submitted!&quot;); $(&quot;#msg&quot;).show(); console.log(f) &#125; ) &#125;); event.preventDefault(); &#125;); $(&quot;#revealing&quot;).submit(function(event) &#123; $(&quot;#msg&quot;).hide(); let amount = $(&quot;#actual-amount&quot;).val(); let secretText = $(&quot;#reveal-secret-text&quot;).val(); let productId = $(&quot;#product-id&quot;).val(); EcommerceStore.deployed().then(function(i) &#123; i.revealBid(parseInt(productId), web3.toWei(amount).toString(), secretText, &#123;from: web3.eth.accounts[0], gas: 440000&#125;).then( function(f) &#123; $(&quot;#msg&quot;).show(); $(&quot;#msg&quot;).html(&quot;Your bid has been successfully revealed!&quot;); console.log(f) &#125; ) &#125;); event.preventDefault();&#125;); if ($(&quot;#product-details&quot;).length &gt; 0) &#123; console.log(window.location); console.log(&quot;Search Params = &quot; + new URLSearchParams(window.location)) let productId = new URLSearchParams(window.location.search).get(&apos;id&apos;); console.log(productId); renderProductDetails(productId); &#125; &#125;&#125;;function renderProductDetails(productId) &#123; console.log(&quot;renderProductDetails&quot;); console.log(productId); EcommerceStore.deployed().then(function(i) &#123; i.getProduct(productId).then(function(p) &#123; console.log(&quot;getProduct&quot;); console.log(p[4]); let content = &quot;&quot;; ipfs.cat(p[4]).then(function(stream) &#123; console.log(stream); let content = Utf8ArrayToStr(stream); $(&quot;#product-desc&quot;).append(&quot;&lt;div&gt;&quot; + content + &quot;&lt;/div&gt;&quot;); &#125;); $(&quot;#product-image&quot;).append(&quot;&lt;img src=&apos;http://127.0.0.1:8080/ipfs/&quot; + p[3] + &quot;&apos; width=&apos;250px&apos; /&gt;&quot;); $(&quot;#product-price&quot;).html(displayPrice(p[7])); $(&quot;#product-name&quot;).html(p[1].name); $(&quot;#product-auction-end&quot;).html(displayEndHours(p[6])); $(&quot;#product-id&quot;).val(p[0]); $(&quot;#revealing, #bidding&quot;).hide(); let currentTime = getCurrentTimeInSeconds(); if (currentTime &lt; p[6]) &#123; $(&quot;#bidding&quot;).show(); &#125; else if (currentTime - (60) &lt; p[6]) &#123; $(&quot;#revealing&quot;).show(); &#125; &#125;) &#125;)&#125;function Utf8ArrayToStr(array) &#123; var out, i, len, c; var char2, char3; out = &quot;&quot;; len = array.length; i = 0; while(i &lt; len) &#123; c = array[i++]; switch(c &gt;&gt; 4) &#123; case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: // 0xxxxxxx out += String.fromCharCode(c); break; case 12: case 13: // 110x xxxx 10xx xxxx char2 = array[i++]; out += String.fromCharCode(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)); break; case 14: // 1110 xxxx 10xx xxxx 10xx xxxx char2 = array[i++]; char3 = array[i++]; out += String.fromCharCode(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0)); break; default: break; &#125; &#125; return out;&#125;function getCurrentTimeInSeconds()&#123; return Math.round(new Date() / 1000);&#125;function displayPrice(amt) &#123; return &apos;Ξ&apos; + web3.fromWei(amt, &apos;ether&apos;);&#125;function displayEndHours(seconds) &#123; let current_time = getCurrentTimeInSeconds() let remaining_seconds = seconds - current_time; if (remaining_seconds &lt;= 0) &#123; return &quot;Auction has ended&quot;; &#125; let days = Math.trunc(remaining_seconds / (24*60*60)); remaining_seconds -= days*24*60*60 let hours = Math.trunc(remaining_seconds / (60*60)); remaining_seconds -= hours*60*60 let minutes = Math.trunc(remaining_seconds / 60); if (days &gt; 0) &#123; return &quot;Auction ends in &quot; + days + &quot; days, &quot; + hours + &quot;, hours, &quot; + minutes + &quot; minutes&quot;; &#125; else if (hours &gt; 0) &#123; return &quot;Auction ends in &quot; + hours + &quot; hours, &quot; + minutes + &quot; minutes &quot;; &#125; else if (minutes &gt; 0) &#123; return &quot;Auction ends in &quot; + minutes + &quot; minutes &quot;; &#125; else &#123; return &quot;Auction ends in &quot; + remaining_seconds + &quot; seconds&quot;; &#125;&#125;function saveProduct(reader, decodedParams) &#123; let imageId, descId; saveImageOnIpfs(reader).then(function(id) &#123; imageId = id; saveTextBlobOnIpfs(decodedParams[&quot;product-description&quot;]).then(function(id) &#123; descId = id; saveProductToBlockchain(decodedParams, imageId, descId); &#125;) &#125;)&#125;function buildProduct(product, id) &#123; console.log(&quot;buildProduct&quot;); console.log(id); let node = $(&quot;&lt;div/&gt;&quot;); node.addClass(&quot;col-sm-3 text-center col-margin-bottom-1&quot;); node.append(&quot;&lt;img src=&apos;http://localhost:8080/ipfs/&quot; + product[3] + &quot;&apos; width=&apos;150px&apos; /&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[1] + &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[2] + &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + new Date(product[5] * 1000) + &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + new Date(product[6] * 1000) + &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;Ether &quot; + product[7] + &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;a href=&apos;product.html?id=&quot; + id + &quot;&apos;class=&apos;btn btn-primary&apos;&gt;Show&lt;/a &gt;&quot;) return node;&#125;;function saveProductToBlockchain(params, imageId, descId) &#123; console.log(params); let auctionStartTime = Date.parse(params[&quot;product-auction-start&quot;]) / 1000; let auctionEndTime = auctionStartTime + parseInt(params[&quot;product-auction-end&quot;]) * 24 * 60 * 60 EcommerceStore.deployed().then(function(i) &#123; i.addProductToStore(params[&quot;product-name&quot;], params[&quot;product-category&quot;], imageId, descId, auctionStartTime, auctionEndTime, web3.toWei(params[&quot;product-price&quot;], &apos;ether&apos;), parseInt(params[&quot;product-condition&quot;]), &#123;from: web3.eth.accounts[0], gas: 440000&#125;).then(function(f) &#123; console.log(f); $(&quot;#msg&quot;).show(); $(&quot;#msg&quot;).html(&quot;Your product was successfully added to your store!&quot;); &#125;) &#125;);&#125;function saveImageOnIpfs(reader) &#123; return new Promise(function(resolve, reject) &#123; const buffer = Buffer.from(reader.result); ipfs.add(buffer) .then((response) =&gt; &#123; console.log(response) resolve(response[0].hash); &#125;).catch((err) =&gt; &#123; console.error(err) reject(err); &#125;) &#125;)&#125;function saveTextBlobOnIpfs(blob) &#123; return new Promise(function(resolve, reject) &#123; const descBuffer = Buffer.from(blob, &apos;utf-8&apos;); ipfs.add(descBuffer) .then((response) =&gt; &#123; console.log(response) resolve(response[0].hash); &#125;).catch((err) =&gt; &#123; console.error(err) reject(err); &#125;) &#125;)&#125; 2)删除buildproduct函数123456789101112function buildProduct(product) &#123; console.log(product[3]); let node = $(&quot;&lt;div/&gt;&quot;); node.addClass(&quot;col-sm-3 text-center col-margin-bottom-1&quot;); node.append(&quot;&lt;img src=&apos;http://localhost:8080/ipfs/&quot; + product[3] + &quot;&apos; width=&apos;150px&apos; /&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[1]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[2]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[5]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;&quot; + product[6]+ &quot;&lt;/div&gt;&quot;); node.append(&quot;&lt;div&gt;Ether &quot; + product[7] + &quot;&lt;/div&gt;&quot;); return node;&#125;]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（五）]]></title>
    <url>%2F2018%2F03%2F09%2FTruffle5%2F</url>
    <content type="text"><![CDATA[选择图片，点击submit,将图片提交到ipfs,并且返回IPFS的HASH值，再通过HASH从IPFS读取图片。 1. 创建react项目1)安装box模版12npm install -g truffletruffle unbox react 2)运行本地智能合约123truffle developcompilemigrate 3）终端验证效果 2. 完成前端UI逻辑1)拷贝以下代码替换app.js文件里代码123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123;Component&#125; from 'react'class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; imgSrc: null &#125; &#125; render() &#123; return (&lt;div className="App"&gt; &lt;h2&gt;上传图片到IPFS：&lt;/h2&gt; &lt;div&gt; &lt;label id="file"&gt;Choose file to upload&lt;/label&gt; &lt;input type="file" ref="file" id="file" name="file" multiple="multip le"/&gt; &lt;/div&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; &#123; var file = this.refs.file.files[0]; var reader = new FileReader(); reader.readAsArrayBuffer(file) reader.onloadend = (e) =&gt; &#123; console.log(reader); &#125; &#125;&#125;&gt;Submit&lt;/button&gt; &lt;/div&gt; &#123; this.state.imgSrc ? &lt;div&gt; &lt;h2&gt;&#123;"http://localhost:8080/ipfs/" + this.state.imgSrc&#125;&lt;/h2&gt; &lt;img alt="区块链部落" style=&#123;&#123; width: 300&#125;&#125; src=&#123;"http://localhost:8080/ipfs/" + this.state.imgSrc&#125;/&gt; &lt;/div&gt; : &lt;img alt=""/&gt;&#125;&lt;/div&gt;); &#125;&#125;export default App 2)浏览器端验证效果 3. 安装ipfs-api1)终端定位到项目根目录，安装ipfs-api12cd react-copynpm install --save-dev ipfs-api 2)atom打开项目，node_modules文件夹中查看ipfs-api安装包,验证安装是否成功。 4. App.js导入IPFS在src目录下的App.js文件中第一行import下面插入下面代码12const ipfsAPI = require(&apos;ipfs-api&apos;);const ipfs = ipfsAPI(&#123;host: &apos;localhost&apos;, port: &apos;5001&apos;, protocol: &apos;http&apos;&#125;); 5. 实现上传图片到IPFS的Promise函数继续在刚刚插入的代码下面添加以下代码。123456789101112let saveImageOnIpfs = (reader) =&gt; &#123; return new Promise(function(resolve, reject) &#123; const buffer = Buffer.from(reader.result); ipfs.add(buffer).then((response) =&gt; &#123; console.log(response) resolve(response[0].hash); &#125;).catch((err) =&gt; &#123; console.error(err) reject(err); &#125;) &#125;)&#125; 并在render函数的button onclick事件中的console.log(reader);代码下面插入以下代码，此代码的作用是当触发点击事件后，上传数据到IPFS1234saveImageOnIpfs(reader).then((hash) =&gt; &#123; console.log(hash); this.setState(&#123;imgSrc: hash&#125;)&#125;); 6. 运行测试确认网络连接正常。 1)第一个终端运行，启动前端服务1npm start 2）第二个终端运行,启动节点服务1ipfs daemon 3）浏览器前端测试点击choose Files按钮，选择一张图片，然后点击submit按钮，返回哈希值和图片下面我们完成将图片哈希存储到区块链 7. 配置合约1) 删除contracts文件下Simple.sol 2) 新建一文件Album.sol,代码拷贝以下123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.18;contract Album &#123; struct Photo &#123; address author; string title; string hash; &#125; address internal owner; Photo[] public photos; modifier onlyOwner() &#123; require(msg.sender == owner); _; &#125; function Album() public &#123; owner = msg.sender; &#125; function addPhoto(string title, string hash) public &#123; photos.push(Photo(msg.sender, title, hash)); &#125; function getPhotosNum() public view returns(uint)&#123; return photos.length; &#125; function clearPhotos() public onlyOwner &#123; delete photos; &#125;&#125; 8. 配置编译设置migrations文件下2_deploy_contracts.js文件，拷贝以下代码替换原代码 12345var Album = artifacts.require("./Album.sol");module.exports = function(deployer) &#123; deployer.deploy(Album);&#125;; 9. App.js导入合约1) 在App.js文件中第一行import下面插入以下代码，完成智能合约导入12import AlbumContract from '../build/contracts/Album.json'import getWeb3 from './utils/getWeb3' 2) 在第6行const ipfs=ipfsAPI({host: &#39;localhost&#39;, port: &#39;5001&#39;, protocol: &#39;http&#39;});下面插入以下代码，用来存储合约12345//合约实例const contract = require('truffle-contract');const album = contract(AlbumContract);let account;let albumInstance; 3) 在App组件上面增加一个Phote组件类123456789101112class Photo extends Component &#123; render()&#123; return ( &lt;li&gt; &lt;p&gt;相片名称: &#123;this.props.photoDetail.title&#125;&lt;/p&gt; &lt;p&gt;上传地址: &#123;this.props.photoDetail.author&#125;&lt;/p&gt; &lt;p&gt;相片hash: &#123;this.props.photoDetail.hash&#125;&lt;/p&gt; &lt;img alt="" style=&#123;&#123;width: 600&#125;&#125; src=&#123;"http://ipfs.io/ipfs/"+this.props.photoDetail.hash&#125; /&gt; &lt;/li&gt; ); &#125;&#125; 4）用以下代码替换掉App组件，完成前端UI更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167class App extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; photos: [], web3: null &#125; &#125; componentWillMount() &#123; // Get network provider and web3 instance. // See utils/getWeb3 for more info. getWeb3 .then(results =&gt; &#123; this.setState(&#123; web3: results.web3 &#125;) // Instantiate contract once web3 provided. this.instantiateContract() &#125;) .catch(() =&gt; &#123; console.log('Error finding web3.') &#125;) &#125; instantiateContract() &#123; album.setProvider(this.state.web3.currentProvider) // Get accounts. this.state.web3.eth.getAccounts((error, accounts) =&gt; &#123; album.at(CONTRACT_ADDRESS).then((instance) =&gt; &#123; albumInstance = instance console.log(instance.address) console.log(accounts[0]) account = accounts[0] //获取相册 albumInstance.getPhotosNum().then(result =&gt; &#123; let num = result.c[0] console.log("照片数量:") console.log(num) for(let i = 0; i&lt;num; i++)&#123; albumInstance.photos(i).then(result2 =&gt; &#123; let photo = &#123;&#125; photo.author = result2[0] photo.title = result2[1] photo.hash = result2[2] console.log(photo) let oldPhotos = this.state.photos oldPhotos.push(photo) this.setState(&#123; photos: oldPhotos &#125;) &#125;) &#125; &#125;) &#125;) &#125;) &#125; render() &#123;// // 遍历数组创建新的 组件数组// let photosdiv = this.state.photos.map((val,index) =&gt;// &lt;Photo index=&#123;index&#125; key=&#123;index&#125; photoDetail=&#123;val&#125; /&gt;// )// return ( &lt;div className="App"&gt; &lt;div&gt; &lt;h1&gt;相册:&lt;/h1&gt; &lt;ul&gt; &#123;this.state.photos.map((val,index) =&gt; &lt;Photo index=&#123;index&#125; key=&#123;index&#125; photoDetail=&#123;val&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;添加新相片&lt;/h1&gt; &lt;p&gt; &lt;label htmlFor="photoTitle"&gt;相片名:&lt;/label&gt; &lt;input type="text" id="photoTitle" ref="photoTitle" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="file" id="photoFile" name="photoFile" ref="photoFile" /&gt; &lt;/p&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; &#123; var name = this.refs.photoTitle.value if(!name)&#123; alert("请填写相片名"); return false; &#125; var file = this.refs.photoFile.files[0]; if(!file)&#123; alert("请选择图片"); return false; &#125; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.onloadend = function(e)&#123; console.log(reader); //上传数据到ipfs saveImageOnIpfs(reader).then((hash) =&gt; &#123; console.log("图片已经成功上传至ipfs"); console.log(hash); //将新图片写入区块链 albumInstance.addPhoto(name, hash, &#123;from: account&#125;).then(result =&gt; &#123; console.log('写入成功'); //写入成功，更新state中的photos //获取相册 albumInstance.getPhotosNum().then(result =&gt; &#123; let num = result.c[0] console.log("照片数量:") console.log(num) albumInstance.photos(num-1).then(result2 =&gt; &#123; let photo = &#123;&#125; photo.author = result2[0] photo.title = result2[1] photo.hash = result2[2] let oldPhotos = this.state.photos oldPhotos.push(photo) this.setState(&#123; photos : oldPhotos &#125;) &#125;) &#125;) &#125;).catch((err) =&gt; &#123; console.log("写入失败") console.error(err) &#125;) &#125;) &#125;.bind(this); &#125; &#125;&gt;添加&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 5) 终端运行123truffle developcompilemigrate 结果12345678Deploying Album...... 0xeed67fe8d612303d2e7d4da7ed64fe29608417c8eb0c5f3ca6c26f1914d4aef3Album: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network...... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts...truffle(develop)&gt; 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0为部署在本地的合约地址 6) 最后在第16行let albumInstance;下面面插入合约地址，此合约地址为执行migrate命令部署后的地址。1let CONTRACT_ADDRESS="0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0"; 10.运行测试程序确认网络连接正常。 1)第一个终端运行，启动前端服务1npm start 2）第二个终端运行,启动节点服务1ipfs daemon 3) 前端测试]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用框架Hexo在IPFS上搭建个人博客]]></title>
    <url>%2F2018%2F03%2F07%2FIPFS1%2F</url>
    <content type="text"><![CDATA[Hexo+IPFS [Mac环境]IPFS是基于区块链的星际文件系统（IPFS），将博客挂在IPFS的区块链上，不需要折腾服务器，不需要各种配置，只要买个域名就行。Hexo 是一个快速、简洁且高效的博客框架。 1. 配置HEXO1) 安装 Node.js 在安装HEXO前，您必须检查电脑中是否已安装Node.js.用下面命令查询已安装node版本1node --version 2) 安装 HEXO 接下来只需要使用 npm 即可完成 Hexo 的安装12npm install hexo -gnpm install hexo-cli -g 3) 创建本地工作目录 public下创建一个文件夹,如blog-ipfs 12cd ~/public/mkdir blog-ipfs 4) 初始化你的本地站点 然后进入blog-ipfs里安装Hexo 12cd blog-ipfshexo init 5) 生成静态页面1hexo generate 6) 启动服务 启动本地服务，进行文章预览调试1hexo server 浏览器输入http://localhost:4000 浏览器端出现以下页面 2. 自定义网站模版和内容2.1 设置个人模版hexo提供了一个默认模版(上图)，如果想更改成自己喜欢的模版怎么办? 1）先定位到Hexo站点目录下，在终端输入以下命令先下载模版 12cd blog-ipfsgit clone https://github.com/beevesnoodles/hexo-theme-grace.git themes/grace 2）下载完成后，阅读README.md文档，按照文档步骤安装插件12npm install hexo-renderer-sass --savenpm install hexo-generator-feed --save 3）修改配置文件_config.yml中theme属性为theme: grace，启用模版。 4）在终端继续输入以下命令完成模版调试1hexo server --debug 出现Database saved，浏览器里输入 http://localhost:4000/ 查看你的站点了 2.2 使用Atom更改内容如果没有安装atom.先把Atom下载下来，阅读官方文档飞行手册，完成配置。1）终端执行下面命令，用atom打开12cd ~/public/blog-ipfsatom . 2）使用atom修改source文件夹下hello-world.md文件123456---title: 使用框架Hexo在IPFS上搭建个人博客categories: Hexo---![github](http://p3d3seyjq.bkt.clouddn.com/github.png)这是我的第一篇博客！ 3）打开根目录下_config.yml文件，设置语言和昵称，详情阅读Next模版 123456title: LEO&apos;S BLOGsubtitle:description:author: 赵东春language: zh-CNtimezone: 4）调试 1hexo server --debug 浏览器端出现最终页面效果: 5）最后执行下面命令生成静态网页1hexo g 3. 配置IPFS3.1 安装1) 下载，进入IPFS官方下载地址，点击”download go-ipfs”下载压缩包。 2)解压，压缩包解压后得到一个go-ipfs的文件夹，终端打开12cd go-ipfsls 查看文件夹下有五个文件，LICENSE build-log ipfs README.md install.sh 3）安装，用下面命令将其中的ipfs文件移动到文件夹/usr/local/bin中1mv ipfs /usr/local/bin/ipfs 4）测试，是否安装成功12345ipfs helpUSAGE: ipfs - Global p2p merkle-dag filesystem.... 3.2 启动本地IPFS节点1) 先初始化IPFS1ipfs init 2) 用下面命令查看文件是否存在123cd ~/.ipfslsopen ./ 3) 启动节点服务器1ipfs daemon 此时，你可以在http://localhost:5001/webui打开自己的操作台。 3.3 将Hexo博客部署到IPFS节点上Hexo是一个静态博客生成器，执行hexo generate后，会在博客目录生成/Public目录,该目录即为全部博客内容. 1) 终端定位到博客所在public目录，执行ipfs add -r public命令123cd ~/public/blog-ipfsipfs add -r publicadded QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY public QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY即为博客网站的site_hash,你可以通过任意运行IPFS的节点访问 2) 浏览器访问 https://ipfs.io/ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY/ 效果如下: 注意：部署到ipfs节点之前，需运行vpn。css丢失不用管，后面一绑定域名，重定向就好了。 3.4 网络同步这步很重要，很多问题，都是因为没有同步造成的，切记：发布IPNS之前要同时开启同步和VPN.1ipfs daemon 3.5 发布到IPNS上1) 发布,需另启一终端12$ ipfs name publish QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKYPublished to QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi: /ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY 2) 验证12$ ipfs name resolve QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi/ipfs/QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKY 3) IPNS访问https://ipfs.io/ipns/QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi/ 4. 绑定独立域名刚好我有一个zhaodongchun.top域名，只需要将zhaodongchun.top解析到上述地址即可。 1) 添加TXT记录为dnslink=/ipns/QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi 2)添加域名A记录为gateway.ipfs.io 确保vpn和节点服务器启动状态，浏览器输入域名：zhaodongchun.top 5. 更新，优化上面讲的是hexo博客的生成与部署，你可以对Hexo进行进一步的配置和优化，发表新的文章，然后hexo g生成新的public，再通过ipfs add即ipfs publish即可实时更新在线博客。步骤如下,别忘了vpn同时开启。1234ipfs add -r public/ipfs daemonipfs name publish QmU37Lm3ERhbqgM9DR8By2v8MxDtmWm93NMx5HLeN3DGKYipfs name resolve QmPwPhAzoMZ6yVjjSY8rdEqhpuwC4JfohJxTpu2pXop9Yi]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（四）]]></title>
    <url>%2F2018%2F03%2F05%2FTruffle4%2F</url>
    <content type="text"><![CDATA[这次用Truffles实现“一刻永流传”，网站效果详看网址。学习在区块链上刻字是怎么实现的？ 开始总结]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（三）]]></title>
    <url>%2F2018%2F03%2F04%2FTruffle3%2F</url>
    <content type="text"><![CDATA[前端增加一按钮和一个输入框，如果在输入框输入数据，点 击按钮后，前端自动修改数据。 开始总结]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（二）]]></title>
    <url>%2F2018%2F03%2F03%2FTruffle2%2F</url>
    <content type="text"><![CDATA[用Truffle运行一个叫tutorialtoken的TT代币钱包demo，实现类似于钱包imtoken的功能，详看官方文档。 1. 打包前后端应用1) 终端中创建一个工作目录12mkdir oz-workspacecd oz-workspace 2) 安装tutorialtoken模版1truffle unbox tutorialtoken 3) 安装第三方库1npm install zeppelin-solidity 2. 创建”TutorialToken”智能合约1) 在contracts/文件夹下创建一个TutorialToken.sol文件,增加以下代码1234pragma solidity ^0.4.17;import &apos;zeppelin-solidity/contracts/token/ERC20/StandardToken.sol&apos;;contract TutorialToken is StandardToken &#123;&#125; 2) 设置代币参数，增加以下代码块到合约中1234string public name = &apos;TutorialToken&apos;;string public symbol = &apos;TT&apos;;uint8 public decimals = 2;uint public INITIAL_SUPPLY = 12000; 3) 完成合约，在上面代码块下面增加下面代码1234function TutorialToken() public &#123; totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY;&#125; 3. 编译和部署智能合约1) 在migrations/文件夹下创建一个2_deploy_contracts.js文件，增加以下代码1234var TutorialToken = artifacts.require(&quot;TutorialToken&quot;);module.exports = function(deployer) &#123; deployer.deploy(TutorialToken);&#125;; 2) 准备编译合约，使用一个工具Ganache，下载运行后,将会生成一个端口为7545的区块链。 3) 编译1truffle compile 4) 部署1truffle migrate 输出类似下面结果123456789101112131415Using network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... ... 0xa4470beb31f490e26b9a8b0d677cb7107ae5ef5bf40f8ee59fe040d35ca4f598 Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0Saving successful migration to network... ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956Saving artifacts...Running migration: 2_deploy_contracts.js Deploying TutorialToken... ... 0xcc01dcbe77f79cf4c21e5642bfee50a6db78b7d6dedb9f8b363ec4110e92436d TutorialToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10Saving successful migration to network... ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0Saving artifacts... Ganache会列出交易记录 4. 和新代币交互1) 拷贝Ganache工具中HTTP://127.0.0.1:7545粘贴到MetaMask，创建一个7545网络;拷贝Ganache工具中助记词candy maple cake sugar pudding cream honey rich smooth crumble sweet treat到MetaMask中的”7545”网络”Custom RPC”中。 2) 想办法vpn,否则网页端不显示代币TT余额Balance: 3) 终端，启动服务1npm run dev 浏览器窗口自动打开，界面如下 4) 下面给不同的账户转账。Ganache中查看，现在有10个账户，第一个账户已经有余额，从另外几个账户中选择一个账户的地址（建议第二个账户），复制后粘贴到网页端的“Address”框中， 在”Amount”框中输入2000。 5) 点击”Transfer”，弹出MetaMask交易确认界面。 6) 点击”Submit”，交易处理成功后显示”Transfer successful”，Ganache显示交易数据。 7) 在网页端MetaMask,更改第一个账户到第二个账户 8) 在浏览器中刷新，将会连接到当前MetaMask账户，显示余额为2000 TT,代表转账成功。]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Truffle课程笔记（一）]]></title>
    <url>%2F2018%2F03%2F02%2FTruffle1%2F</url>
    <content type="text"><![CDATA[Truffle是针对基于以太坊的Solidity语言的一套开发框架。本身基于Javascript。 1. 简单创建一个项目 1) 安装truffle框架1npm install -g truffle 2) 卸载truffle框架1npm uninstall -g truffle 3) 查看版本123$ truffle versionTruffle v4.1.0 (core: 4.1.0)Solidity v0.4.19 (solc-js)s 4) 创建项目12mkdir demotruffle init 简单分析：有三个文件夹contracts migrations test结论：最简单truffle框架，没有和任何前端结合。 2. 使用BOXES创建一个项目使用truffle的最佳姿势是使用集成好的BOXES生成项目 1) 安装truffle box 1truffle unbox react 如果前端使用react，推荐使用react盒子。 2) 目录结构分析 简单分析：有八个文件夹config contracts migrations node_modules public scripts src test 重要文件1：contract文件夹用来存放合约，其中simpleStorage.sol文件为默认合约，可以自定义修改 重要文件2：src文件夹用来存放代码，其中App.js用来修改代码 重要文件3：最底部truffle.js很有用 3. 如何运行一个项目总体流程是：先编译合约，再部署合约，然后同步MetaMask和本地私有网络账号，最后运行服务。 3.1 编译12truffle developcompile develop产生一个本地测试区块链，得到一个区块链服务器地址http://localhost:9545/和十个账号Accounts:，以及12个单词的助记词Mnemonic： compile编译后得到一个build文件夹,此文件夹存放abi和字节码 3.2 部署1migrate 部署后得到一个合约地址simpleStorage，这样当前网络上已经部署合约。 3.3 MetaMask和本地私有网络账号同步对比本地网络地址localhost：9545和网页端本地网络地址localhost:8545，需要将网页端和本地链接起来 1) 拷贝本地网络地址http://localhost:9545/ 2) 定位到网页端metamask钱包中custom RPC,将其粘贴进来 3) 拷贝助记词到MetaMask中，通过此方法不需要使用web3转账。 用web3解决网络钱包中没有钱的问题 12345678web3.eth.getBalance("0x821aea9a577a9b44299b9c15c88cf3087f3b5544")//得到余额var count=web3.toWei(50,'ether');count;count//50eth转换为位web3.eth.sendTransaction(&#123;from:"",to:"",value:count&#125;)//发送count从钱包地址1到钱包地址2. 运行完代码后，到网页端metamask钱包查看余额，为150eth就对了。 3.4 启动服务1npm run start 启动第二个终端，运行npm run start,如果结果为5则正常]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（四)]]></title>
    <url>%2F2018%2F03%2F01%2FReact4%2F</url>
    <content type="text"><![CDATA[本次学习后端知识，学习JSX和组件。明白React唯一不可缺少的是render函数 1. React前端思维方式1） 安装create-react-app安装包确认Node.js和npm安装好之后，执行下面命令安装1npm install --global create-react-app 2） 初始化项目先创建一个demo项目1create-react-app demo 3）终端，运行下面代码12cd demonpm start 恭喜，第一个React应用诞生！ 2. 案例学习2.1 案例一再开一终端,demo目录下运行atom .打开目录，先找到入口index.js，拷贝以下代码 123456let str=&quot;这是一个测试&quot;;ReactDom.render( &lt;span&gt; &#123;str&#125; &lt;/span&gt; ) 浏览器端效果 1这是一个测试 注意：JEX语法的实现用花括号{}，注意let和var作用域的不同，var以后尽量少用。 2.2 案例二 通过此案例学习JSX遍历（map） 123456789 let labels=[ &quot;xixi&quot;, &quot;haha&quot; ];labels.map(function(s)&#123; return( &lt;h1&gt;&#123;s&#125;&lt;/h1&gt; )&#125;) 浏览器端效果 12xixihaha 注意：数组里可以放标签对象，map是js代码中的数组遍历的函数，js代码可以嵌入xml,xml代码也可以嵌入js 2.3 案例三1234567891011121314151617181920import React,&#123;Component&#125; from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;; let persons = [&quot;汪峰&quot;,&quot;章子怡&quot;,&quot;萨贝岭&quot;] class Person extends Component &#123; render() &#123; return ( &lt;div&gt; &#123; persons.map((name) =&gt; &#123; return &lt;h1&gt;姓名：&#123;name&#125;&lt;/h1&gt; &#125;) &#125; &lt;/div&gt; ) &#125; &#125; ReactDOM.render( &lt;Person /&gt;, document.getElementById(&apos;root&apos;) ); 浏览器端效果 123姓名：汪峰姓名：章子怡姓名：萨贝岭 注意：第一行{Component}的意思是从库中导入基类Component,第四行class Person extends Component这句话的意思是创建一个叫Person的组件类，Person的父类就是Component 3. 设计React组件3.1. 组件的创建 1234567891011121314class Person extends Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;me&lt;/h1&gt; &lt;h1&gt;you&lt;/h1&gt; &lt;/div&gt; ) &#125; &#125;ReactDom.render( &lt;Person /&gt;,document.getElementById(&apos;root&apos;)); 浏览器端效果 12meyou 3.2. 组件的生命周期 1） 装载过程 2) 更新过程 3) 卸载过程 3.3. React组件的state和prop的局限学习如何使用状态机变量测试一个输入框，输入框输入数字，下面展示相应数字12345textarea style=&#123;&#123; width:400, height:200 &#125;&#125; defaulvalue:&quot;请输入内容...&quot; 创建一个构造函数,用来存储状态机变量123456constructor(props)&#123; super(props); this.state=&#123; textValue:&quot;请输入内容...&quot; &#125;&#125;]]></content>
      <categories>
        <category>React前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（三)]]></title>
    <url>%2F2018%2F02%2F28%2FReact3%2F</url>
    <content type="text"><![CDATA[本节我们学会使用web中的Flex布局 学习之前三必问开始学习基本概念容器的flexbox属性项目的flexbox属性实现骰子效果 1. 学习之前三必问1.1 Flex布局是什么Flex布局是W3C提出了一种新的网页布局（layout）方案，Flex是Flexible Box的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。 总结一句话来说：Flex布局就是一种弹性的网页布局方式。 1.2 为什么学习Flex布局1）传统布局 传统布局解决方案:基于盒状模型，依赖 display属性 + position属性 + float属性。 2）Flex布局 Flex布局解决方案:对于那些特殊布局非常方便，比如，垂直居中。 对比两种布局方式结论为：Flex布局将成为未来布局的首选方案 1.3 怎么学习Flex布局1）把握一个中心 任何一个容器都可以指定为Flex布局 2）理解两个概念 Flex 容器（flex container）`Flex 项目（flex item） 3）运用多个属性 6个属性设置在容器上 flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 6个属性设置在项目上 orderflex-growflex-shrinkflex-basisflexalign-self 总结一句话就是：搞清楚container和item的异同，高频练习flex属性就好了 2. 开始学习基本概念1）第一个概念：Flex容器是采用Flex布局的元素2）第二个概念：Flex项目是容器的子元素 图释：容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。项目默认沿主轴排列，主轴很重要，运用flex属性需要先判断主轴方向。 如何判断主轴 项目（item）排序方式如果从上往下，上下方向为主轴项目（item）排序方式如果从左往右，左右方向为主轴 牢记一句话就是：容器里包括项目，项目排序方向为主轴 3. 容器的flexbox属性 flex-direction属性 flex-wrap flex-flow justify-content align-items align-content 4. 项目的flexbox属性5. 实现骰子效果 5.1 初始化环境1）常用包 Reactreact-domreact-scripts 2）安装包1npm install --save react-redux 3）卸载包1npm uninstall --save react-redux 4）将react-redux安装在devDependencies里面 1npm install --save-dev react-redux 5）将react-redux卸载在devDependencies里面1npm uninstall --save-dev react-redux 6）启动项目12cd my-Appnpm start 5.2 初识目录结构执行顺序是先定位到index.js render 函数里就两个函数: 第一个参数放一个 标签对象，&lt;div&gt;&lt;/div&gt;或&lt;span&gt;&lt;/span&gt; 第二个参数放一个节点 注意以下几点： react里面的语法属于JSX语法 JSX相当于js和xml的结合体 XML范围大于HTML HTML是XML的一个子集 如果想让body里面的div按照flex布局，那么需要将container这个body设置为flex1display:flex; 盒子不再重叠只有当display属性为flex时，才有主轴和交叉轴概念。 容器(body)的flex属性12345678910111213141516171819body&#123; flex-direction:row; flex-direction:column; flex-direction:row-reverse; flex-direction:column-reverse; flex-wrap:nowrap; flex-wrap:wrap; flex-flow:row wrap; justify-content:flex-start;//主轴 justify-content:flex-end; justify-content:center; justify-content:space-between; justify-content:space-around; align-items:flex-start;//交叉轴 align-items:flex-end;//交叉轴 align-items:stretch;//交叉轴&#125; 项目(item)的flex属性12345678910div&#123; order:0; flex-grow:1; flex-shrink:1; flex-grow:1; flex-basis:300px;//固定，flex-shrink和grow将不起作用 flex:0 1 auto;//是否压缩，拉伸，值 align-self:flex-start;&#125;]]></content>
      <categories>
        <category>React前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（二）]]></title>
    <url>%2F2018%2F02%2F26%2FReact2%2F</url>
    <content type="text"><![CDATA[运行一个todolist项目，学习react运行原理。 1. 了解并会使用React对比html+css+js和react有什么不同先阅读官网文档 1） 设置环境 运行下面命令，确认已经安装npm1npm -v 2）工具下载1sudo npm install create-react-app -g 3）初始化1create-react-app todolist 4）运行测试。 12cd todolistnpm run start 稍等片刻，服务如果打开localhost:3000，代表服务已经运行成功,以后我们修改值后，都会在这个终端显示结果。 2. 更新内容保持服务打开，我们需要再打开一个atom终端，两个atom同时运行，一个用来开启服务，另一个用来修改值用于测试。 1）运行命令12cd todolistatom . 在atom中打开todolist目录 2）分析目录结构。 src目录 App.js 写一个标签 index.js 只有一个作用 package.json public目录 index.html 在atom中同时打开上面四个文件，结合浏览器，我们学习下这几个文件的关系。 3）编辑src/App.js找到下面字段：1&lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt; 修改为：1&lt;h1 className=&quot;App-title&quot;&gt;Test&lt;/h1&gt; 保存后，你会发现locahost页面也相应更新。 3. 接口1） 导入,导出 尝试修改index.js文件,定位此代码1import App from &apos;./App&apos;; 更改为1import App,&#123;Test3,Test2&#125; from &apos;./App&apos;; 切换到App.js文件，查看页面底部import后面的 理解导入导出，导入两种方式。一种是名字，一种带括号的。 2）传值 index.js =&gt; app.js 动态添加组件，并实时渲染出来]]></content>
      <categories>
        <category>React前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React课程笔记（一）]]></title>
    <url>%2F2018%2F02%2F26%2FReact1%2F</url>
    <content type="text"><![CDATA[React 是一个用于构建用户界面的 JAVASCRIPT 库，React主要用于构建UI。先阅读官方文档。 1. 开始之前1) 为什么学习React？ 答：学会了react可以用最快的速度在安卓端和ios端创建轻应用界面UI。轻应用特点： 点开后都是网页，长处是应用审核效率高，短处是做酷炫效果难。 网页只需要开发一次，安卓端和ios端打开后效果是一样的。 2) 怎么学习React? 答：顺序学习下面五项内容。 了解并使用ES6了解并会使用React会使用web中的Flex布局了解react-router 2. 了解并使用ES6我们已经知道了react是javascript库，那么学习库之前需要先熟悉javascript.ECMAScript 和 JavaScript 的关系：前者是后者的语法规格，后者是前者的一种实现。 那么问题又来了，我们为什么要学ECMAScript? 答：ECMAScript6是JavaScript语言的下一代标准,现代浏览器对 ES6 的支持相当迅速，尤其是 Chrome 和 Firefox 浏览器。而且它的目标是使得JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 html+css+js// es =&gt; 语言规范// js =&gt; es规范下的方言(有自己独特的地方，也有不想要的地方)// node =&gt; 基于es规范下的一套方法集合// nvm node 版本管理工具// vim 的使用+linux常用命令 学习之前需要先配置javaScript运行环境。我们选择的是Node.js,Node.js是一个基于Chrome V8引擎的JavaScript运行环境。node还有一个版本管理工具nvm不错，好处在哪，后面说。 3. 安装node3.1 安装node和nvm输入node -v命令查看已安装node版本，如果通过以下命令安装nvm成功,但是不能启动命令，是因为环境变量没有配置12//node -v//brew install nvm 3.2 配置环境1) 定位到根目录123cd ~ls -avim .bash_profile 2) 添加以下命令： 12export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 3)重新source 1source .bash_profile 到此，nvm环境配置安装好了。 使用nvm的好处就是以后更新版本只需要指定版本号，自动切换版本后旧版本的功能也就能用了。 4)测试，新建一个工作目录，然后创建一个test1.js的文件,内容就拷贝下面代码吧。1console.log(&apos;hi!&apos;) 写好后，我们在终端输入下面命令，看下效果1node test1.js 结果：hi! 5）以后每次写完代码，用node 文件名运行就好了。 有时根据需要配合一些nvm命令，用来切换版本实现一些特殊功能等等。 nvm -v 列出nvm所有信息nvm ls-remote 列出可以全部安装的版本号nvm install v7.0.0 下载需要的版本nvm use v7.0.0 切换到固定版本nvm current 查看当前版本nvm ls 查看当前系统内已经安装的版本 4. ES6语言有了node环境，我们在环境下通过案例学习ES6的常用语法。 1）常量const 1234 &#123;const a= 100;console.log(a);//100&#125; 需要注意： ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的 2）变量let,var let是ES6新加的一个变量修饰符，ES6推荐在函数中使用 let 定义变量，而非 var： 123456var a=100;&#123; let a = 200; console.log(a);//200&#125;console.log(a);//100 有几点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let只在最近的代码块中(花括号)有效 let和var 在作用域的问题上是有区别的 let是一个块级的变量声明，只在当前作用域有效 var相反 3）函数functions 函数声明方式: function 方法名（参数列表）{代码块}12function method1()&#123;&#125; 如果函数需要把执行结果返回，就直接用return返回1234567let method1 = function add(a,b)&#123; const c=a+b; return c;&#125;let result = add(1,2);console.log(result);//3 4）箭头函数=&gt; ES6中，箭头函数就是函数的一种简写形式，对比上面普通的声明方式，有什么不同，箭头函数声明方式:（参数列表） =&gt; {代码块}123456let method2 = (a,b) =&gt; &#123; return a+b;&#125;let result = method2(10,5);console.log(result);//15 5）数组 [] []来声明一个数组1let arraya = [1,2,3]; 和其他编程语言一样通过下标取值1console.log(array[2]); 解构赋值1arraya[2]=10; let后面的变量数组和等号右边的数组的下标是统一的12345let arraya = [1,2,3];let [a,b,c]=arraya;console.log(&apos;a:&apos;+a);//a:1console.log(&apos;b:&apos;+b);//b:2console.log(&apos;c:&apos;+c);//c:3 push方法添加数据123let arraya = [45,56];arraya.push(34,23,34);console.log(arraya);//45,56,34,23,34 map方法遍历设置元素并把每一个元素依次传入方法体执行123arraya.map(function(value,index)&#123; console.log(index+&apos;+&apos;+value);&#125;) 如果箭头函数列表只有一个参数，可以省掉括号1234567value =&gt; &#123; console.log(index+&apos;:&apos;+value);&#125;arraya.map(value =&gt; &#123; console.log(index+&apos;:&apos;+value); &#125;) 数组的扩展运算符1234let array = [23,45,6,7]console.log(array);console.log(...array);//结果：23，45，6，7console.log([...array]); 改变元素值1234let array = [23,45,6,7]let array2=array;array2[0]=1;console.log(array); 利用数组的扩展运算符解决复制问题1let array3=[...array]; 利用…实现数组的合并12345let array = [1,2,3,4];let array2 = [5,6,4];let array3 = [1000];let newarray = [...array, ...array2, ...array3,6,5];console.log(newarray); 6）对象{} 声明一个对象 12345const zhangsan=&#123; name:&apos;张三&apos;, age:18, gender:&apos;man&apos;&#125; 修改一个对象 1zhangsan.name=&apos;李四&apos; 对象的解构赋值 12345678let objecta=&#123; name:2, age:10&#125;let &#123;name,age&#125;= objecta;console.log(name);console.log(objecta.name); 7）promise ES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者rejected。promise 是一个类，通过new关键字来实例化一个对象. 123456789 var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调：12p.then((val) =&gt; console.log(&quot;Promise Resolved&quot;, val), (err) =&gt; console.log(&quot;Promise Rejected&quot;, err)); 以下代码模拟一个数据库，等待三秒返回链接成功 1234567function connectServer()&#123; //定时 setTimeout(() =&gt; &#123; console.log(&apos;链接成功&apos;); &#125;,3000);&#125;connectServer(); 如果以上代码测试成功，终端显示链接成功后，再实现下面逻辑,函数功能实现如果链接上数据库ip,打印链接成功，如果不能链接，打印错误 123456789101112131415161718192021function connectP(ip)&#123; let promise = new Promise((resolve,reject) =&gt; &#123; if(ip == &apos;10.0.0.119&apos;)&#123; reject(&apos;错误&apos;) &#125;else&#123; setTimeout(() =&gt; &#123; resolve(&apos;链接成功&apos;) &#125;，3000); &#125; &#125;); return promise;&#125;let promise=connectP(&apos;10.0.0.119&apos;);promise.then((data) =&gt;&#123; console.log(data); &#125;)promise.catch((error) =&gt; &#123; console.log(&apos;error:&apos;+error) &#125;) 8）类class类是同一种物体的抽象概念，类的声明：class+类名{类实现} 1234567class Coin&#123;//构造一个类的实例对象constructor(name,number)&#123; this.name = name; this.number = number;&#125;&#125; 通过new来创建一个对象12let btc = new Coin();console.log(btc.name+&apos;当前数量：&apos;+btc.number);//name当前数量:number 需要注意几点： 方法的声明不需要function关键字 类=&gt;实例对象 this =&gt; 创建的一个新空对象 通过new来创建一个对象 定义一个莱特币，继承虚拟币1234567891011121314151617class Coin&#123;constructor(name,number)&#123; this.name = name; this.number = number;&#125;&#125;class LTC extends Coin&#123; constructor(name,number)&#123; super(); this.number = number*100; this.name = name; &#125;&#125;let ltc = new LTC(&apos;莱特币1&apos;，9999);console.log(ltc); 结果：LTC {name:&#39;莱特币1&#39;，number:999900} 注意以下几点： super() =&gt; 就是父类的构造函数 5. 总结React理念可总结为一个公式：UI=render(data)]]></content>
      <categories>
        <category>React前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（六）]]></title>
    <url>%2F2018%2F02%2F26%2FSolidity6%2F</url>
    <content type="text"><![CDATA[编写智能合约，构建和部署一个去中心化投票App 1. 投票合约思路： 复制模版改名voting.sol定位到前段代码app.js，更换合约地址和名字将合约拷贝到web端，run，create，submit拷贝合约地址到app.js，替换掉运行truffle develop编辑后npm start,前端启动。 2. 实现不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（五）]]></title>
    <url>%2F2018%2F02%2F09%2FSolidity5%2F</url>
    <content type="text"><![CDATA[12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData = x; &#125; function get() public constant returns (uint) &#123; return storedData; &#125;&#125; 尝试理解一个基本实例 1. 开始之前复盘几个概念枚举：go中关键字iota，solidity中关键字enum结构体： 2. 声明枚举12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.19;contract C &#123; // 声明一个枚举类型ActionChoices // 里面一共有四个值，GoLeft, GoRight, GoStraight, SitStill // 其实位置的值GoLeft等于0，往后逐渐+1 // uint8是无符号整型，它的存储范围是0～255 // ActionChoices相当于是我们自己自定义的一个无符号整型，存储的值的范围由我们自己决定 // 当前案例里面ActionChoices的存储范围为0 ~ 3，在set方法中如果传值超过了3，那么就会越界 enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; // 声明一个ActionChoices类型的变量_choice ActionChoices _choice; // 声明一个ActionChoices类型的常量，defaultChoice // defaultChoice它的值为ActionChoices.GoStraight ActionChoices constant defaultChoice = ActionChoices.GoStraight; // 通过set方法修改变量_choice的值 function setGoStraight(ActionChoices choice) public &#123; _choice = choice; &#125; // get方法，读取变量的_choice的值 function getChoice() constant public returns (ActionChoices) &#123; return _choice; &#125; // 返回常量defaultChoice的值 function getDefaultChoice() pure public returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 12345678910pragma solidity ^0.4.19;contract C &#123; //枚举类型单词首字母大写，里面也是 enum Sex &#123; Man, Women, Unknown &#125; function SexSelf() public view returns (Sex) &#123; return Sex.Man; &#125;&#125; 3. 初始化一个结构体1234567891011pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125;&#125; 123456789101112131415161718192021pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125; //初始化方法一 Person person=Person(30,101,&quot;lillll&quot;); //初始化方法二 Person _person=Person(&#123;stuId:101,age:18,name:&quot;liyecjc&quot;&#125;) //元祖 function getPersonInfo() public view returns (uint,uint,string)&#123; return (person.age,person.stuId,person.name); &#125;&#125; 4. 字典（和go语言的区别）123456pragma solidity ^0.4.19;contract MappingExample &#123;mapping(address=&gt;uint) balances;&#125; 5. 众筹合约1234567891011121314151617181920212223pragma solidity ^0.4.19;contract CrowdFunding &#123;//定义一个结构体类型struct Funder&#123; address addr; //出资人地址 uint amout; //出资总额&#125;//定义一个结构体类型struct Campaign&#123;&#125;//通过campaignID给某个对象赞助function contribute(uint campaignID) public payable &#123; Campaign storage c= Campaigns[campaignID]; c.funders[c.numFunders++]=Funder(&#123;add:msg.sender,amout:msg.sender&#125;)&#125;//判断是否达标&#125; 6. 如何把truffle的demo跑起来1) 安装truffle1npm install -g truffle 2) 运行项目模版12009_demotruffle unbox react 找到src下app.js,复制contract文件夹下的migrations.sol代码到web编译器，登陆mask钱包，切换到测试网络，点击set后点击submit,部署到测试网络。1truffle develop 编译出一个build的文件1npm start 运行 修改app.js,增加按钮修改合约数据]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（四）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity4%2F</url>
    <content type="text"><![CDATA[关键字：固定，动态，memory,storage,bytes,push,索引 1. 开始之前复盘几个概念固定字节数组：bytes关键字后面直接带有数字，例如bytes9 names动态字节数组：bytes关键字后面不接数字，例如bytes namesstorage类型：指针传递，传递指针不传递内容，例如bytes storage namesmemory类型：值传递，传递的是内容，例如bytes memory names 2. 固定大小字节数组转动态大小字节数组（不能直接转换）需求：将bytes9 name9转化为bytes name9 思路：尝试两种方法，第一种方法我们通过索引将固定大小字节数组内内容提取出来，再将其内容存储进一个动态大小字节数组，第二种方法我们通过push方法把固定大小字节数组内内容推送给一个动态大小字节数组。 2.1 第一种方法：通过索引1）创建固定数组2）转换数组 创建存储数组，注意数组类型为memory 通过for循环更新存储数组内内容 12345678910111213141516pragma solidity ^0.4.19;contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public constant returns (bytes) &#123; // 创建一个长度为name9的长度的动态大小字节数组，主要用于存储name9里面的字节内容 bytes memory names = new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return names; &#125; &#125; 2.2 第二种方法：通过push方法1）创建固定数组(为方便记忆理解，将字节数组简写为数组)2）创建一个空动态数组,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组)3）通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push123456789101112131415161718pragma solidity ^0.4.19;// 如果想要使用push，动态大小字节数组必须是storage类型// 通过new bytes(0)创建的状态变量/属性默认为storage类型// 在函数里面通过new bytes(0)创建的状态变量/属性默认为memory类型// memory类型的动态大小字节数组不能使用push，只能通过索引更新内容contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes public names = new bytes(0); //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public &#123; for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names.push(name9[i]); &#125; &#125;&#125; 3.字符串转换为固定大小字节数组需求：将字符串&quot;zhaodongchun&quot;转化为固定数组bytes32 思路：直接转化成功，通过声明变量的方式失败。 3.1 直接转化把字符串&quot;zhaodongchun&quot;通过bytes32()转化为固定数组后，值直接返回给函数123456789pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题// string 转换为固定大小字节数组 只有直接传字面量string时好使contract C &#123; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(&quot;zhaodongchun&quot;); //直接将字面量字符串转换为固定大小字节数组，转换成功 &#125;&#125; 3.2 失败案例1）函数内接参数，通过字符串类型s，值直接返回给函数行参，对比第一种方法，有什么异同。12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //memory类型的string不能转换为固定大小字节数组 function stringToFixedBytes(string s) pure public returns (bytes32) &#123; return bytes32(s); &#125;&#125; 2）编译器提示memory类型的字符串有问题，更改为storage测试依然报错12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //报错 function stringToFixedBytes(string storage s) pure private returns (bytes32) &#123; return bytes32(s); &#125;&#125; 3）如果函数外声明字符串变量，测试依然报错12345678910pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; string s = &quot;liyuechun&quot;; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(s); //报错 &#125;&#125; 4. 固定大小字节数组转换为字符串(不能直接转换)需求：将固定数组bytes9转化为字符串&quot;zhaodongchun&quot; 思路：但是固定可转动态，动态和字符串可直接互转，所以思路是这样，先将固定转动态，再动态转字符串 4.1 通过索引1）创建固定数组2）转换数组 创建存储数组，注意数组类型为memory通过for循环更新存储数组内内容动态数组转换为字符串，将值返回给函数 12345678910111213pragma solidity ^0.4.19;contract C &#123; bytes9 name9=0x6c697975656368756e; function ficTostring() view public returns(string)&#123; bytes memory names=new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return string(names);&#125;&#125; 4.2 通过push方法1）创建固定数组name9(为方便记忆理解，将字节数组简写为数组)2）创建一个空动态数组names,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组)3）通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push4）动态数组names转换为字符串后值返回给函数1234567891011121314pragma solidity ^0.4.19;contract C &#123; // 固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes names = new bytes(0); // 将names9转换为string function fixToString() view public returns (string) &#123; for (uint i=0; i&lt;name9.length; i++) &#123; names.push(name9[i]); &#125; return string(names); &#125;&#125; 5. 固定大小字节数组和可变数组1）固定大小字节数组长度不可修改，内容可以修改12//固定大小字节数组uint [5] T = [1,2,3,4,5]; 2）可变数组可动态修改数组的长度，内容可以修改 12//可变数组 uint [] T = [1,2,3,4,5]; 3）修改可变数组实例 12345678910111213141516171819202122232425 pragma solidity ^0.4.19;contract C &#123; uint [] public T = [1,2,3,4,5]; function setTLength(uint len) public &#123; //可动态修改数组的长度 T.length = len; &#125; function TLength() constant public returns (uint) &#123; return T.length; &#125; // 添加一个数字 function pushANum(uint num) &#123; T.push(num); &#125; //删除整个数组的内容 function deleteTContent() &#123; delete T; &#125;&#125; 6. 二维数组示例 123456789101112131415pragma solidity ^0.4.19;contract C &#123;/* 1 23 45 61 2 34 5 6 */ uint [2][3] T = [[1,2],[3,4],[5,6]]; function T_len() constant public returns (uint) &#123; return T.length; // 3 &#125;&#125;]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（三）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity3%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（二）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（一）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity1%2F</url>
    <content type="text"><![CDATA[如果我们掌握了Solidity,就可以开发很多区块链小游戏，说不定还能做出一爆款，收获荣耀和名利。详见官方文档 以太坊开发使用的钱包 通过一个demo简单讲解区块链原理 Solidity面向对象编程 以太坊私有链搭建 联盟链 truffle,embark框架 ipfs怎么配置 如何写一个去中心化拍卖的网站 1. 以太坊开发使用的钱包1) Ethereum Wallet 以太坊完整钱包，发代币需要钱包，下载到本地几十G吧,同步时间比较长，可以以后安装 2) MyEtherWallet 网页版在线轻钱包，不需要同步所有数据 3) Metamask MetaMask是一款在谷歌浏览器Chrome上使用的插件类型的以太坊钱包,不需要下载，安装方法详见此链接吧，安装完后在浏览器右边会出现小狐狸头像，钱包界面下有这几项 main Ethereum Network Ropsten Test Network kovan Test Network Rinkeby Test Network Localhost 8545 custom RPC 第一项是以太坊主网，第二项到第四项是测试网络，主网只在你的产品正式上线才用，测试千万别进主网，我们经常用的是Ropstrn Test Network和Kovan Test Network,如果我们需要内部局域网测试，偶尔也用localhost 8545。获取Ropsrn Test Network可以直接点击buy按钮。获取Kovan Test Network测试网络上的以太坊代币的渠道，需要到这个社区，聊天文本本框内输入此格式@epheph 你的钱包地址epheph会发送eth到你钱包， 4) Parity 偶尔用一下，用于开发联盟链。 2. 两个框架1) truffleframework 进官网后，点开BOXES看菜单项，看看里面都有什么，看到react了吗，以后我们会用到，看看还有什么，发现一个宠物商店，是一个领养猫的app。这些都是现成的demo,集成好的框架 2) embark 这个框架也不错，集成了ipfs,封装好了api,以后用到时我们再详细介绍. 3. 通过一个 demo简单讲解区块链原理打开上面的demo后会有六个菜单项，分别为Hash Block Blockchain Distributed Tokens Coinbase，下面详细解释。 3.1. 了解什么是哈希先看第一项，哈希是什么，在data框内随意输入一个字符试试，会发现下面的哈希值也会同步变化，这就是说你输入内容的同时，网络会根据你的内容计算哈希值。为了便于理解，咱们拿版权保护举个例子，看看版权怎么记录，怎么溯源，怎么存储的问题。 假如有一天我写了一篇文章，提交到了区块链，假如有个后来人改了个字然后说这篇文章是他写的，你怎么判断是谁写的。 看看哈希计算怎么解决这个问题，如果内容一旦发生变化，即使改一个字，哈希值也会变，这样我们只需要存储哈希就行了，不需存取整篇文章。从现实角度讲，盗版，抄袭，无法杜绝，但是通过哈希计算我们可以很简单的识别出谁是原著谁是编著。 原著和编著的区别，从法律角度讲，原著不可随意更改，编著可以随意编撰，不需负法律责任。 3.2. 区块的概念再看第二项block页面有几个值，Block Nonce Data Hash对比上面的四个值，我们先搞清楚什么是挖矿，在Data文本框内输入一个随机数111,再修改Nonce后面文本框内的值，只要你不断尝试，终有一天你会找到一个Nonce值和哈希值匹配上，我们也可以点击下面的Mine按钮，计算机会自动计算出一个正确的Nonce值和哈希值，我们可以理解挖矿就是找Nonce的值，直到满足哈希值要求的条件。1Block+Nonce+Data=Hash 其实从上面公式我们也能分析出来挖矿就是用三个值拼接成一个哈希值的过程 输入下面代码，在电脑终端运行一个小demo，可帮助我们深入理解区块链运行原理，详见春哥的教程 1234sudo npm install blockchain-cli -gblockchainmine zhaobc]]></content>
      <categories>
        <category>ETH智能合约开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（二）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper2%2F</url>
    <content type="text"><![CDATA[上一篇我们用web scraper这款爬虫工具爬取了单页的数据，这篇我们试下怎么一次设置抓取多页。 1. 看官方视频先进官网,看下Pagination这个视频，虽然是英文中国人也能看懂的，跟着视频操作几遍就好了。 2. 打开我们要抓取的网站3. 抓取数据4. 导出数据4.1 导出到Excel表格抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 4.2 对数据进行筛选从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（一）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper1%2F</url>
    <content type="text"><![CDATA[一直以来，我天天想着爬虫，做梦也想，可是也仅仅是想想罢了，最近需要几百份白皮书，了解到一款叫web scraper的爬虫工具，可以让普通人不敲代码轻松掌握爬虫技巧，下面我盘点下具体做法 1.下载 Web ScraperWeb Scraper是谷歌Chrome浏览器上的一个插件，你需要电脑上安装有chrome浏览器，且已经翻墙，具体怎么翻墙就不多介绍了，自个看外链吧。如果你已经进入谷歌浏览器，请先点击网页左上角的Apps图标,在弹出的菜单中选择Web Store进入Chrome网上应用商店，在搜索框内输入关键词Web scraper,在列表中选中由Martins Balodist提供的Web Scraper,点击右上角的蓝色按钮添加至CHROME,将其添加进谷歌的扩展程序中后会有个蛛网标志出现在搜索框后面。 2. 打开 Web Scraper快捷键 Ctrl + Shift + I / F12打开开发者工具，找到Web Scraper。建议先进官网,看下Watch the intro video这个视频介绍，虽然是英文中国人也能看懂的，如果照葫芦画瓢跟着视频操作几遍，相信你已拿下它了，下面的内容你不看也会爬虫了。 3. 抓取数据我们以抓取block.cc网站的数据为例,先点击进入网站 3.1 新建Sitemap点击 Create New Sitemap,在弹出的下拉菜单中选择Create sitemap,Sitemap name后面的文本框内输入block，这里是自定义名字，容易记忆就行，我自定义的是要抓取的网站名字，Start URL后面的文本框内输入要抓取的网站入口网址https://block.cc/,最后点击按钮Create Sitemap，这样我们就创建了一个名字为block-cc的网站地图，这是我们想抓取数据的网站入口，也就是起点。 3.2 设置Sitemap在页面最下面找到一个蓝色的按钮Add new selector,点击创建选择器，会弹出来选择器设置页面，有下面几项，我们一一解释 Id ———-这个Id需要自定义，最好定义一个英文名字，原则就是简洁，好记。Type ——-这个类型很重要，其实经常用的就三类：“文本”，”链接”，”元素”Selector —-这个是选择器，第一个按钮Select，当按下时，在网页上点击后出现绿色框。 其实重要的是捋清楚网页结构，搞清除哪些是文本，哪些是链接，哪些是元素，爬虫就很简单了。 1）点击网页最下面的蓝色按钮Add new selector创建一个选择器，Id设置为elemment-box,Type设置为Element, 2）点击Selector后面的Select按钮，鼠标移动到网页中，定位到币种列表下第一项BTC-比特币最右边，是不是出现个绿色框，当如下图所示状态时，代表已经选中此行，点击，第一行变红，继续点击下一行，所有行都变成红色就可以了。 3）点击Done selecting!确认选中目标，字段会自动填充到Selector后面的文本框中 4）勾选上Multiple,最后点击Save selector保存，这样我们的一个选择器就创建成功了。 想想为什么我们创建一个类型为元素的选择器，其实看看网页结构就清楚了，我们要抓取的数据都包裹在一个个容器中，我们需要先抓取容器，共50行，下面抓取每一行内容。 5）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name,Type为Text，当点击选择按钮后，选择名称下面的容器，别选择容器内文本，确认后面字段为span.mgl10,不需要选择multiple,直接Save selector就可以了 6）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为num,Type为Text，当点击选择按钮后，选择#下面的容器，别选择容器内文本，确认后面字段为div.col-md-1.col-xs-1,不需要选择multiple,直接Save selector就可以了 7）确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name-link,Type为Link，当点击选择按钮后，选择名称下面的容器，确认后面字段为div.col-md-3 a,不需要选择multiple,直接Save selector就可以了 至此，父页面设置好了，下面我们抓取子页面的内容 8）点击BTC-比特币的链接，进入子页面，然后进入name-link目录，在此目录下分别创建web,amout,resum，whitepaper,四个选择集 9）web选择集设置Type为Text，Selector后面字段为p.col-sm-4:nth-of-type(1) a 10）amout选择集设置Type为Text，Selector后面字段为div.col-xs-6 p.num 11）resum选择集设置Type为Text，Selector后面字段为p.break-line-4 12）whitepaper选择集设置Type为Link,Selector后面字段为p.col-sm-4:nth-of-type(6) a 3.3 抓取数据完成上面的设置后，点击Sitemap block的下拉菜单选择scrape,保持延迟为默认2000，点击蓝色按钮Start scraping就开始抓取数据了. 4. 导出数据4.1 导出到Excel表格抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 4.2 对数据进行筛选从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用框架Hexo在Github上搭建个人博客]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo+Github [Mac环境] 假如你有一个Github帐号，我们就可以开始了，如果你说没有，就去注册好了。想想咱们注册微信时也不是很难的事吧，准备好一个邮箱就行了，真的别的都不需要。 1. 配置远程和本地Github1.1 在 Github 上创建一个仓库（Repo）登陆Github网址，用你的账号登陆进去，点右上角的+，弹出菜单选择New repository,在弹出的Repository name下面的文本框内按照yourname.github.io 这种格式输入，然后选中 Public, 最后点击绿色的Create repository创建成功。 重新登陆，点右上角你的头像，在弹出的菜单中选中Your profile,会发现“youname.github.io”分支创建成功，点击进去，在右边找到Settings,在左侧栏最下面找到Deploy keys,点击Add deploy key,输入你的”key”,密匙的求解过程请参见Git密匙,至此你的远程仓库部分已经配置完成。 如果你对git很感兴趣，或者，对git的命令行方式很头疼的，可以阅读此物: Git入门教材 ⚠️我的git仓库名字为zhaodongchun.github.io,你的就用你自己的名字好了. 1.2 确认本地已经安装好 git 和 npm在终端输入下面两条命令，确认已经安装好git和npm,如果电脑还没装这两个东西的，请参照官方文档安装：Git入门教材+npm中文文档 12git --versionnpm --version 2. 配置Hexo 1） 安装 hexo 先通读官方文档hexo自动部署网站,不需要看内容，快速翻一遍知道有这个工具在这里就可以了，以后需要时再调用它。然后终端输入以下命令12npm install hexo -gnpm install hexo-cli -g 2） 创建本地工作目录 先登陆到github，点击你的分支yourname.github.io,在右边有个绿色的按钮Clone or download,点开后点击copy to clipboard把自己的git地址拷贝出来，在终端cd到你希望把站点放置的位置，下面我cd到Desktop了 12cd ~/Desktopgit clone https://github.com/zhaodongchun/zhaodongchun.github.io.git 3）初始化你的本地站点 12345hexo init yourname.github.iocd yourname.github.ionpm install hexo-deployer-git --savehexo generatehexo server 在终端打完以上命令后，如果最后显示Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了，需要注意的是这个效果是hexo默认模版landscape的效果，下面我们学学怎么更换模版为Next模版。 4）设置个人模版 这里涉及两个东西，一个是Hexo,一个是Next,我们先到Hexo模版，先看看都有哪些模版可供我们选择，如果你点击模版下面的大标题名字后会进入到github的源文件地址，和创建本地工作目录一样，可以把它的Git地址拷贝出来。先以next模版为例，先定位到Hexo站点目录下，在终端输入以下命令安装 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，修改配置文件_config.yml中的 theme 字段为 next后保存，至此我们完成了站点配置。在终端继续输入以下命令完成模版调试，如果再此出现Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了 1hexo server --debug 5） 使用Atom码文章 先把Atom下载下来，官网直接下载安装或在终端输入下面命令也可以，如果对Atom还不熟悉没关系，先从官方文档开始逐渐建立Atom语法吧，在线阅读:飞行手册 给 Atom 安装一个命令行面板，Atom 里同时按command+，调出setting面板，定位到install选项，在文本框中搜索platformio-ide-terminal后点击install安装atom包，安装完成后按command+shift+t在下面会出现一个终端，这个包的作用就是解决总是来回切换atom和终端的问题。 完成上面的操作后，我们对包大概有了个概念，下面继续安装一个markdown包，点击Atom菜单下的Preference的左侧倒数第二项+ install，输入markdown，依次安装几个包 markdown-scroll-synclinter-markdownmarkdown-writermarkdown-tocmarkdown-pdfmarkdown-preview 然后就是随便折腾一会，看看这几个都实现什么功能，接下来用markdown书写文章的过程中会经常使用这几个包/Desktop/zhaodongchun.github.io/zhaodongchun.github.io,这是我的目前位置，你可以在mac终端输入ls查看你是否在根路径下，然后终端输入atom .在atom中打开所有文件，然后使用快捷键command+shift+t打开atom终端，mac的终端就可以关闭了，在左侧栏定位到source文件夹下的_posts文件夹，展开后有一个hello-world.md文件，这个文件就是网站上看到的源文件。我们用一下刚才掌握的几个快捷键试试 command+w 关闭当前标签command+shift+m 终端ctrl+shift+m 预览 “&gt;” 块引用 “-” 任务列表“0.” 有序列表 快捷键熟悉差多了，再回去翻翻Next模版，设置下站点配置文件和主题配置文件，设置语言和你的昵称，基本上博客就可以了，保存后在终端输入下面调试命令,如果再此出现Database saved，代表本地站点已经初始化完成，可以在浏览器输入http://localhost:4000/查看你的站点了。 1hexo server --debug 3. 部署到 Github 上把本地文件上传到github远程前，我们需要告诉atom上传到的路径，先登陆github，进入zhaodongchun.github.io这个分支，点击绿色的clone or download按钮拷贝出来路径，再进入atom，左侧根目录会有一个_config.yml文件，下面我们设置下这个配置文件，先把拷贝出来的路径粘贴到url后面，注意截止到/,将root后面改成你的github上的仓库一样，repo后面的直接把你拷贝出来的粘贴就行了，注意:后面的空格不要少，这样atom就知道上传给谁了。 url: https://github.com/konglongyinger/zhaodongchun.github.io/ root: /zhaodongchun.github.io deploy: type: git repo: https://github.com/konglongyinger/zhaodongchun.github.io.git 修改完成后保存，在atom终端输入下面命令，在github上查看上传结果，如果发现文件已经显示，就可以进入github你的分支下的settings，往下翻找到GitHub Pages这里，将source下的None改为master branch,点击保存后，会出现绿色的一条提示Your site is published at https://konglongyinger.github.io/zhaodongchun.github.io/，后面链接就是你的网址了，现在你可以点击看看效果。 1hexo deploy 4. 调试网站 如果每次在本地修改文章，可以用下面命令调试预览 1hexo s --debug 如果改动了配置文件，在上传到github前最好使用清理命令，清除public目录 1hexo clean 如果完成阶段性任务了可以用下面命令上传到github 1hexo deploy 5. 域名绑定首先你的有个域名，举例来说我是从百度买的，有了域名后再分三步走。 1） 配置CNAME 在hexo文件夹下的source中新建一个文本文档， 里边输入刚才我们买到的域名的二级域名。举例来说，我申请的是zhaodongchun.com，就填写zhaodongchun.com,然后保存为CNAME.注意大写的CNAME. 2） 配置解析服务器 接下来进域名服务商的后台进行域名解析设置,添加CNAME记录类型，解析线路默认就好了，记录值为zhaodongchun.github.io,配置好后我们本地重新上传到github。 3） 配置站点设置文件重定向 还记得我们没有绑定域名之前设置的配置文件吗，绑定域名后需要重新设置下url和root,否则css有可能会丢失，将其设置回默认，如下设置： url: https://zhaodongchun.comroot: / 4）好，到此为止，重新执行下面命令将文件上传到github，浏览器输入你的域名就可以正常登陆了。 123hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
