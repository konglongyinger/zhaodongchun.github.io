<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React课程笔记（一）]]></title>
    <url>%2F2018%2F02%2F26%2FReact1%2F</url>
    <content type="text"><![CDATA[为什么学习React,区块链工程师分类两种，底层和前端百度轻应用和重应用，轻应用点开后都是网页，优势审核效率高，略势酷炫效果难。轻应用，网页只需要开发一次，安卓端和ios端打开后效果是一样的,接下来两天我们学习下面五项内容。 了解并使用ES6会使用babel,Parcel等工具了解并会使用React会使用web中的Flex布局了解react-router 开始了解并使用ES6 html+css+js// es =&gt; 语言规范// js =&gt; es规范下的方言(有自己独特的地方，也有不想要的地方)// node =&gt; 基于es规范下的一套方法集合// nvm node 版本管理工具// vim 的使用+linux常用命令 先安装node和nvm,输入node -v命令查看已安装node版本，如果通过以下命令安装nvm成功,但是不能启动命令，是因为环境变量没有配置12//node -v//brew install nvm 可以先配置环境，在终端输入以下命令123cd ~ls -avim .bash_profile 然后添加以下命令： 12export NVM_DIR=~/.nvmsource $(brew --prefix nvm)/nvm.sh 然后重新source 1source .bash_profile 到此，nvm环境配置安装好了，好处就是以后更新版本只需要指定版本号，自动下载安装。写一个test1.js,1console.log(&apos;hi!&apos;) 写好后，我们在终端输入下面命令，看下效果1node test1.js 结果：hi! 下面是常用的一些nvm命令 nvm -v 列出nvm所有信息nvm ls-remote 列出可以全部安装的版本号nvm install v7.0.0 下载需要的版本nvm use v7.0.0 切换到固定版本nvm current 查看当前版本nvm ls 查看当前系统内已经安装的版本 ES语言常量const 1234567891011121314//声明一个常量//修饰符 变量名/常量名=初始值；//不需要制定数据类型的，编译系统自动推断const a= 100;const b= &quot;sfasd&quot;;//给常量重新赋值会报错//error:Assignment to constant variable.//a=4545;typeof 常量名称const typea=typeof a;//数字的数据类型是numberconsole.log(typeof b);console.log(a); 变量var1234567891011121314151617181920212223242526272829303132333435//es6 之前和之后都有的一个变量声明修饰符var m=100;console.log(m);m=110;console.log(m);//let es6 新加的一个变量修饰符//let var 差不多//作用域//整个文件是一个代码块//if&#123;这是一个代码块（作用域）&#125;//let 和var 在作用域的问题上是有区别的//let是一个块级的变量声明，只在当前作用域有效//var 相反if(true)&#123;let a = 100;//a 只在最近的代码块中有效//console.log(a);//var 在编译前做的变量提升//虽然var b是在这个代码块中声明的，但是在编译时就自动的把声明代码生成到了全局var b= 100;&#125;//console.log(a);console.log(b);//声明一个对象const zhangsan=&#123; name:&apos;张三&apos;, age:18, gender:&apos;man&apos;&#125;//修改一个对象zhangsan.name=&apos;李四&apos; 函数function1234567891011121314//函数声明方式 function 方法名（参数列表）&#123;代码块&#125;function method1()&#123;&#125;function add(a,b)&#123; const c=a+b; //如果函数需要把执行结果返回，就直接用return返回 return c; //console.log(c);&#125;const d=add(1,2);console.log(d); 会使用babel,Parcel等工具了解并会使用React会使用web中的Flex布局了解react-router总结]]></content>
      <categories>
        <category>React</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（六）]]></title>
    <url>%2F2018%2F02%2F26%2FSolidity6%2F</url>
    <content type="text"><![CDATA[跑通一个智能合约 开始开始之前复盘几个概念枚举：go中关键字iota，solidity中关键字enum结构体： 一. 声明枚举12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.19;contract C &#123; // 声明一个枚举类型ActionChoices // 里面一共有四个值，GoLeft, GoRight, GoStraight, SitStill // 其实位置的值GoLeft等于0，往后逐渐+1 // uint8是无符号整型，它的存储范围是0～255 // ActionChoices相当于是我们自己自定义的一个无符号整型，存储的值的范围由我们自己决定 // 当前案例里面ActionChoices的存储范围为0 ~ 3，在set方法中如果传值超过了3，那么就会越界 enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; // 声明一个ActionChoices类型的变量_choice ActionChoices _choice; // 声明一个ActionChoices类型的常量，defaultChoice // defaultChoice它的值为ActionChoices.GoStraight ActionChoices constant defaultChoice = ActionChoices.GoStraight; // 通过set方法修改变量_choice的值 function setGoStraight(ActionChoices choice) public &#123; _choice = choice; &#125; // get方法，读取变量的_choice的值 function getChoice() constant public returns (ActionChoices) &#123; return _choice; &#125; // 返回常量defaultChoice的值 function getDefaultChoice() pure public returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 12345678910pragma solidity ^0.4.19;contract C &#123; //枚举类型单词首字母大写，里面也是 enum Sex &#123; Man, Women, Unknown &#125; function SexSelf() public view returns (Sex) &#123; return Sex.Man; &#125;&#125; 二. 初始化一个结构体1234567891011pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125;&#125; 123456789101112131415161718192021pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125; //初始化方法一 Person person=Person(30,101,&quot;lillll&quot;); //初始化方法二 Person _person=Person(&#123;stuId:101,age:18,name:&quot;liyecjc&quot;&#125;) //元祖 function getPersonInfo() public view returns (uint,uint,string)&#123; return (person.age,person.stuId,person.name); &#125;&#125; 三. 字典（和go语言的区别）123456pragma solidity ^0.4.19;contract MappingExample &#123;mapping(address=&gt;uint) balances;&#125; 四. 众筹合约1234567891011121314151617181920212223pragma solidity ^0.4.19;contract CrowdFunding &#123;//定义一个结构体类型struct Funder&#123; address addr; //出资人地址 uint amout; //出资总额&#125;//定义一个结构体类型struct Campaign&#123;&#125;//通过campaignID给某个对象赞助function contribute(uint campaignID) public payable &#123; Campaign storage c= Campaigns[campaignID]; c.funders[c.numFunders++]=Funder(&#123;add:msg.sender,amout:msg.sender&#125;)&#125;//判断是否达标&#125; 五. 如何把truffle的demo跑起来 安装truffle 1npm install -g truffle 运行项目模版 12009_demotruffle unbox react 找到src下app.js,复制contract文件夹下的migrations.sol代码到web编译器，登陆mask钱包，切换到测试网络，点击set后点击submit,部署到测试网络。1truffle develop 编译出一个build的文件1npm start 运行 修改app.js,增加按钮修改合约数据 六. 跑一遍投票合约 复制模版 改名voting.sol 定位到前段代码app.js，更换合约地址和名字 将合约拷贝到web端，run，create，submit 拷贝合约地址到app.js，替换掉 运行truffle develop编辑后npm start,前端启动。 总结不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（五）]]></title>
    <url>%2F2018%2F02%2F09%2FSolidity5%2F</url>
    <content type="text"><![CDATA[关键字：枚举，结构体，字典，投票,元祖,dapp 开始开始之前复盘几个概念枚举：go中关键字iota，solidity中关键字enum结构体： 一. 声明枚举12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.19;contract C &#123; // 声明一个枚举类型ActionChoices // 里面一共有四个值，GoLeft, GoRight, GoStraight, SitStill // 其实位置的值GoLeft等于0，往后逐渐+1 // uint8是无符号整型，它的存储范围是0～255 // ActionChoices相当于是我们自己自定义的一个无符号整型，存储的值的范围由我们自己决定 // 当前案例里面ActionChoices的存储范围为0 ~ 3，在set方法中如果传值超过了3，那么就会越界 enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125; // 声明一个ActionChoices类型的变量_choice ActionChoices _choice; // 声明一个ActionChoices类型的常量，defaultChoice // defaultChoice它的值为ActionChoices.GoStraight ActionChoices constant defaultChoice = ActionChoices.GoStraight; // 通过set方法修改变量_choice的值 function setGoStraight(ActionChoices choice) public &#123; _choice = choice; &#125; // get方法，读取变量的_choice的值 function getChoice() constant public returns (ActionChoices) &#123; return _choice; &#125; // 返回常量defaultChoice的值 function getDefaultChoice() pure public returns (uint) &#123; return uint(defaultChoice); &#125;&#125; 12345678910pragma solidity ^0.4.19;contract C &#123; //枚举类型单词首字母大写，里面也是 enum Sex &#123; Man, Women, Unknown &#125; function SexSelf() public view returns (Sex) &#123; return Sex.Man; &#125;&#125; 二. 初始化一个结构体1234567891011pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125;&#125; 123456789101112131415161718192021pragma solidity ^0.4.19;contract Students &#123;//string 结构体声明关键字//Person 结构体类型 struct Person &#123; uint age; uint stuId; string name; &#125; //初始化方法一 Person person=Person(30,101,&quot;lillll&quot;); //初始化方法二 Person _person=Person(&#123;stuId:101,age:18,name:&quot;liyecjc&quot;&#125;) //元祖 function getPersonInfo() public view returns (uint,uint,string)&#123; return (person.age,person.stuId,person.name); &#125;&#125; 三. 字典（和go语言的区别）123456pragma solidity ^0.4.19;contract MappingExample &#123;mapping(address=&gt;uint) balances;&#125; 四. 众筹合约1234567891011121314151617181920212223pragma solidity ^0.4.19;contract CrowdFunding &#123;//定义一个结构体类型struct Funder&#123; address addr; //出资人地址 uint amout; //出资总额&#125;//定义一个结构体类型struct Campaign&#123;&#125;//通过campaignID给某个对象赞助function contribute(uint campaignID) public payable &#123; Campaign storage c= Campaigns[campaignID]; c.funders[c.numFunders++]=Funder(&#123;add:msg.sender,amout:msg.sender&#125;)&#125;//判断是否达标&#125; 五. 如何把truffle的demo跑起来 安装truffle 1npm install -g truffle 运行项目模版 12009_demotruffle unbox react 找到src下app.js,复制contract文件夹下的migrations.sol代码到web编译器，登陆mask钱包，切换到测试网络，点击set后点击submit,部署到测试网络。1truffle develop 编译出一个build的文件1npm start 运行 修改app.js,增加按钮修改合约数据 六. 跑一遍投票合约 复制模版 改名voting.sol 定位到前段代码app.js，更换合约地址和名字 将合约拷贝到web端，run，create，submit 拷贝合约地址到app.js，替换掉 运行truffle develop编辑后npm start,前端启动。 总结不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（四）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity4%2F</url>
    <content type="text"><![CDATA[关键字：固定，动态，memory,storage,bytes,push,索引 开始开始之前复盘几个概念固定字节数组：bytes关键字后面直接带有数字，例如bytes9 names动态字节数组：bytes关键字后面不接数字，例如bytes namesstorage类型：指针传递，传递指针不传递内容，例如bytes storage namesmemory类型：值传递，传递的是内容，例如bytes memory names 一. 固定大小字节数组转动态大小字节数组（不能直接转换）需求 将bytes9 name9转化为bytes name9 思路 尝试两种方法，第一种方法我们通过索引将固定大小字节数组内内容提取出来，再将其内容存储进一个动态大小字节数组，第二种方法我们通过push方法把固定大小字节数组内内容推送给一个动态大小字节数组。 通过索引 创建固定数组 转换数组 创建存储数组，注意数组类型为memory 通过for循环更新存储数组内内容12345678910111213141516pragma solidity ^0.4.19;contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public constant returns (bytes) &#123; // 创建一个长度为name9的长度的动态大小字节数组，主要用于存储name9里面的字节内容 bytes memory names = new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return names; &#125; &#125; 通过push方法 创建固定数组(为方便记忆理解，将字节数组简写为数组) 创建一个空动态数组,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组) 通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push123456789101112131415161718pragma solidity ^0.4.19;// 如果想要使用push，动态大小字节数组必须是storage类型// 通过new bytes(0)创建的状态变量/属性默认为storage类型// 在函数里面通过new bytes(0)创建的状态变量/属性默认为memory类型// memory类型的动态大小字节数组不能使用push，只能通过索引更新内容contract C &#123; //固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes public names = new bytes(0); //将固定大小字节数组转换为动态大小字节数组 function fixedSizeByteArraysToDynamicallySizedByteArray() public &#123; for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names.push(name9[i]); &#125; &#125;&#125; 二.字符串转换为固定大小字节数组需求 将字符串&quot;zhaodongchun&quot;转化为固定数组bytes32 思路 直接转化成功，通过声明变量的方式失败。 直接转化 把字符串&quot;zhaodongchun&quot;通过bytes32()转化为固定数组后，值直接返回给函数123456789pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题// string 转换为固定大小字节数组 只有直接传字面量string时好使contract C &#123; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(&quot;zhaodongchun&quot;); //直接将字面量字符串转换为固定大小字节数组，转换成功 &#125;&#125; 失败案例 函数内接参数，通过字符串类型s，值直接返回给函数行参，对比第一种方法，有什么异同。 12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //memory类型的string不能转换为固定大小字节数组 function stringToFixedBytes(string s) pure public returns (bytes32) &#123; return bytes32(s); &#125;&#125; 编译器提示memory类型的字符串有问题，更改为storage测试依然报错 12345678pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; //报错 function stringToFixedBytes(string storage s) pure private returns (bytes32) &#123; return bytes32(s); &#125;&#125; 如果函数外声明字符串变量，测试依然报错 12345678910pragma solidity ^0.4.19;// string 转换为固定大小字节数组的问题contract C &#123; string s = &quot;liyuechun&quot;; function stringToFixedBytes() pure public returns (bytes32) &#123; return bytes32(s); //报错 &#125;&#125; 三.固定大小字节数组转换为字符串(不能直接转换)需求 将固定数组bytes9转化为字符串&quot;zhaodongchun&quot; 思路 但是固定可转动态，动态和字符串可直接互转，所以思路是这样，先将固定转动态，再动态转字符串 通过索引 创建固定数组 转换数组 创建存储数组，注意数组类型为memory 通过for循环更新存储数组内内容 动态数组转换为字符串，将值返回给函数12345678910111213pragma solidity ^0.4.19;contract C &#123; bytes9 name9=0x6c697975656368756e; function ficTostring() view public returns(string)&#123; bytes memory names=new bytes(name9.length); for(uint i = 0; i &lt; name9.length; i++) &#123; //更新names里面的内容 names[i] = name9[i]; &#125; return string(names);&#125;&#125; 通过push方法 创建固定数组name9(为方便记忆理解，将字节数组简写为数组) 创建一个空动态数组names,注意关键字new(为方便记忆理解，将字节动态数组简写为动态数组) 通过for循环推送内容（固定数组到动态数组），注意两个方法.length .push 动态数组names转换为字符串后值返回给函数1234567891011121314pragma solidity ^0.4.19;contract C &#123; // 固定大小字节数组 bytes9 name9 = 0x6c697975656368756e; bytes names = new bytes(0); // 将names9转换为string function fixToString() view public returns (string) &#123; for (uint i=0; i&lt;name9.length; i++) &#123; names.push(name9[i]); &#125; return string(names); &#125;&#125; 四.固定大小字节数组和可变数组 固定大小字节数组长度不可修改，内容可以修改 12//固定大小字节数组uint [5] T = [1,2,3,4,5]; 可变数组可动态修改数组的长度，内容可以修改 12//可变数组 uint [] T = [1,2,3,4,5]; 修改可变数组实例 12345678910111213141516171819202122232425 pragma solidity ^0.4.19;contract C &#123; uint [] public T = [1,2,3,4,5]; function setTLength(uint len) public &#123; //可动态修改数组的长度 T.length = len; &#125; function TLength() constant public returns (uint) &#123; return T.length; &#125; // 添加一个数字 function pushANum(uint num) &#123; T.push(num); &#125; //删除整个数组的内容 function deleteTContent() &#123; delete T; &#125;&#125; 五.二维数组 示例123456789101112131415pragma solidity ^0.4.19;contract C &#123;/* 1 23 45 61 2 34 5 6 */ uint [2][3] T = [[1,2],[3,4],[5,6]]; function T_len() constant public returns (uint) &#123; return T.length; // 3 &#125;&#125; 总结不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（三）]]></title>
    <url>%2F2018%2F02%2F08%2FSolidity3%2F</url>
    <content type="text"><![CDATA[关键字：固定，动态，memory,storage,bytes,push,索引 开始开发需要使用的钱包1. Ethereum Wallet同步时间比较长，可以以后安装 2. MyEtherWallet需要安装 3. Metamask四种测试网络 main roptest kovtest 如何获取代币，到社区要代币，@epheph 0xF055775eBD516e7419ae486C1d50C682d4170645 local 4. Parity两个框架1.truffleframework2.embark通过一个 demo简单讲解区块链原理打开上面的demo后会有六个菜单项，分别为Hash Block Blockchain Distributed Tokens Coinbase 了解什么是哈希先看第一项，哈希是什么，在data框内随意输入一个字符，试试。 咱们再拿版权保护举个例子，看看版权怎么记录，怎么溯源，怎么存储的问题。 如果有一天我写了一篇文章，提交到了区块链，假如有个人后来改了个字然后说是他写的，你怎么判断是谁写的。 哈希能解决这个问题，如果内容一旦发生变化，即使改一个字，一个空格，哈希也会变，这样我们只需要存储哈希就行了，不需存取整篇文章。从现实角度讲，盗版，抄袭，无法杜绝，但是通过哈希计算我们可以很简单的识别出谁是原著谁是编著。 原著和编著的区别，从法律角度讲，原著不可随意更改，编著可以随意编撰，不需付法律责任。 区块的概念再看第二项blockchain页面有几个值，block Nonce Data,最后是Hash对比上面的四个值，我们先搞清楚什么是挖矿 找noice的值，满足哈希值的条件，这就是挖矿 0000的哈希和20个0的哈希哪个难度大 Block: Nonce: Data: 拼接成一个哈希值 终端输入1234567sudo npm install blockchain-cli -g //安装blockchain显示genesis blockprevious hash:0 //创始区块nonce:94053mine liyc1215bc 用来查看 如何用js实现挖矿过程-逻辑12345678function isValidhashDifficulty(hash,difficulty)&#123;for (var i=0,b=hash.length;i&lt;b;i++)&#123;if (hash[i])!==&apos;0&apos;&#123;break;&#125;&#125;return i&gt;= difficulty;&#125; blockchain 如果更改date,数据损坏，需要重新挖矿，成本会非常高，最少搞定两条链，这就是51%攻击 tokenSolidity面向对象编程以太坊私有链搭建联盟链truffle,embarkipfs怎么配置如何写一个去中心化拍卖的网站总结不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（二）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity2%2F</url>
    <content type="text"><![CDATA[关键字：固定，动态，memory,storage,bytes,push,索引 开始开发需要使用的钱包1. Ethereum Wallet同步时间比较长，可以以后安装 2. MyEtherWallet需要安装 3. Metamask四种测试网络 main roptest kovtest 如何获取代币，到社区要代币，@epheph 0xF055775eBD516e7419ae486C1d50C682d4170645 local 4. Parity两个框架1.truffleframework2.embark通过一个 demo简单讲解区块链原理打开上面的demo后会有六个菜单项，分别为Hash Block Blockchain Distributed Tokens Coinbase 了解什么是哈希先看第一项，哈希是什么，在data框内随意输入一个字符，试试。 咱们再拿版权保护举个例子，看看版权怎么记录，怎么溯源，怎么存储的问题。 如果有一天我写了一篇文章，提交到了区块链，假如有个人后来改了个字然后说是他写的，你怎么判断是谁写的。 哈希能解决这个问题，如果内容一旦发生变化，即使改一个字，一个空格，哈希也会变，这样我们只需要存储哈希就行了，不需存取整篇文章。从现实角度讲，盗版，抄袭，无法杜绝，但是通过哈希计算我们可以很简单的识别出谁是原著谁是编著。 原著和编著的区别，从法律角度讲，原著不可随意更改，编著可以随意编撰，不需付法律责任。 区块的概念再看第二项blockchain页面有几个值，block Nonce Data,最后是Hash对比上面的四个值，我们先搞清楚什么是挖矿 找noice的值，满足哈希值的条件，这就是挖矿 0000的哈希和20个0的哈希哪个难度大 Block: Nonce: Data: 拼接成一个哈希值 终端输入1234567sudo npm install blockchain-cli -g //安装blockchain显示genesis blockprevious hash:0 //创始区块nonce:94053mine liyc1215bc 用来查看 如何用js实现挖矿过程-逻辑12345678function isValidhashDifficulty(hash,difficulty)&#123;for (var i=0,b=hash.length;i&lt;b;i++)&#123;if (hash[i])!==&apos;0&apos;&#123;break;&#125;&#125;return i&gt;= difficulty;&#125; blockchain 如果更改date,数据损坏，需要重新挖矿，成本会非常高，最少搞定两条链，这就是51%攻击 tokenSolidity面向对象编程以太坊私有链搭建联盟链truffle,embarkipfs怎么配置如何写一个去中心化拍卖的网站总结不识庐山真面目，只缘身在此山中。]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用Solidity7天跑通以太坊开发（一）]]></title>
    <url>%2F2018%2F02%2F05%2FSolidity1%2F</url>
    <content type="text"><![CDATA[7天后，我们可以开发很多区块链小游戏，水滴石穿，天才来自积累，先展示大纲 以太坊开发使用的钱包 通过一个demo简单讲解区块链原理 Solidity面向对象编程 以太坊私有链搭建 联盟链 truffle,embark框架 ipfs怎么配置 如何写一个去中心化拍卖的网站 开始一. 以太坊开发使用的钱包1. Ethereum Wallet以太坊完整钱包，发代币需要钱包，下载到本地几十G吧,同步时间比较长，可以以后安装 2. MyEtherWallet网页版在线轻钱包，不需要同步所有数据 3. MetamaskMetaMask是一款在谷歌浏览器Chrome上使用的插件类型的以太坊钱包,不需要下载，安装方法详见此链接吧，安装完后在浏览器右边会出现小狐狸头像，钱包界面下有这几项 main Ethereum Network Ropsten Test Network kovan Test Network Rinkeby Test Network Localhost 8545 custom RPC 第一项是以太坊主网，第二项到第四项是测试网络，主网只在你的产品正式上线才用，测试千万别进主网，我们经常用的是Ropstrn Test Network和Kovan Test Network,如果我们需要内部局域网测试，偶尔也用localhost 8545。获取Ropsrn Test Network可以直接点击buy按钮。获取Kovan Test Network测试网络上的以太坊代币的渠道，需要到这个社区，聊天文本本框内输入此格式@epheph 你的钱包地址epheph会发送eth到你钱包， 4. Parity偶尔用一下，用于开发联盟链。 两个框架1.truffleframework进官网后，点开BOXES看菜单项，看看里面都有什么，看到react了吗，以后我们会用到，看看还有什么，发现一个宠物商店，是一个领养猫的app。这些都是现成的demo,集成好的框架。 2.embark这个框架也不错，集成了ipfs,封装好了api,以后用到时我们再详细介绍. 二. 通过一个 demo简单讲解区块链原理打开上面的demo后会有六个菜单项，分别为Hash Block Blockchain Distributed Tokens Coinbase，下面详细解释。 1. 了解什么是哈希先看第一项，哈希是什么，在data框内随意输入一个字符试试，会发现下面的哈希值也会同步变化，这就是说你输入内容的同时，网络会根据你的内容计算哈希值。为了便于理解，咱们拿版权保护举个例子，看看版权怎么记录，怎么溯源，怎么存储的问题。 假如有一天我写了一篇文章，提交到了区块链，假如有个后来人改了个字然后说这篇文章是他写的，你怎么判断是谁写的。 看看哈希计算怎么解决这个问题，如果内容一旦发生变化，即使改一个字，哈希值也会变，这样我们只需要存储哈希就行了，不需存取整篇文章。从现实角度讲，盗版，抄袭，无法杜绝，但是通过哈希计算我们可以很简单的识别出谁是原著谁是编著。 原著和编著的区别，从法律角度讲，原著不可随意更改，编著可以随意编撰，不需负法律责任。 2. 区块的概念再看第二项block页面有几个值，Block Nonce Data Hash对比上面的四个值，我们先搞清楚什么是挖矿，在Data文本框内输入一个随机数111,再修改Nonce后面文本框内的值，只要你不断尝试，终有一天你会找到一个Nonce值和哈希值匹配上，我们也可以点击下面的Mine按钮，计算机会自动计算出一个正确的Nonce值和哈希值，我们可以理解挖矿就是找Nonce的值，直到满足哈希值要求的条件。1Block+Nonce+Data=Hash 其实从上面公式我们也能分析出来挖矿就是用三个值拼接成一个哈希值的过程 输入下面代码，在电脑终端运行一个小demo，可帮助我们深入理解区块链运行原理，详见春哥的教程 1234sudo npm install blockchain-cli -gblockchainmine zhaobc]]></content>
      <categories>
        <category>Solidity</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（二）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper2%2F</url>
    <content type="text"><![CDATA[上一篇我们用web scraper这款爬虫工具爬取了单页的数据，这篇我们试下怎么一次设置抓取多页。 开始步骤一：看官方视频先进官网,看下Pagination这个视频，虽然是英文中国人也能看懂的，跟着视频操作几遍就好了。 步骤二：打开我们要抓取的网站步骤三：抓取数据步骤四：导出数据导出到Excel表格 抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 对数据进行筛选 从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图 总结众里寻他千百度，蓦然回首，那人却在灯火阑珊处。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫-用web scraper抓取百份白皮书（一）]]></title>
    <url>%2F2018%2F02%2F04%2Fweb%20scraper1%2F</url>
    <content type="text"><![CDATA[一直以来，我天天想着爬虫，做梦也想，可是也仅仅是想想罢了，最近需要几百份白皮书，了解到一款叫web scraper的爬虫工具，可以让普通人不敲代码轻松掌握爬虫技巧，下面我盘点下具体做法 开始步骤一：下载 Web ScraperWeb Scraper是谷歌Chrome浏览器上的一个插件，你需要电脑上安装有chrome浏览器，且已经翻墙，具体怎么翻墙就不多介绍了，自个看外链吧。如果你已经进入谷歌浏览器，请先点击网页左上角的Apps图标,在弹出的菜单中选择Web Store进入Chrome网上应用商店，在搜索框内输入关键词Web scraper,在列表中选中由Martins Balodist提供的Web Scraper,点击右上角的蓝色按钮添加至CHROME,将其添加进谷歌的扩展程序中后会有个蛛网标志出现在搜索框后面。 步骤二：打开 Web Scraper快捷键 Ctrl + Shift + I / F12打开开发者工具，找到Web Scraper。建议先进官网,看下Watch the intro video这个视频介绍，虽然是英文中国人也能看懂的，如果照葫芦画瓢跟着视频操作几遍，相信你已拿下它了，下面的内容你不看也会爬虫了。 步骤三：抓取数据我们以抓取block.cc网站的数据为例,先点击进入网站 新建Sitemap 点击 Create New Sitemap,在弹出的下拉菜单中选择Create sitemap,Sitemap name后面的文本框内输入block，这里是自定义名字，容易记忆就行，我自定义的是要抓取的网站名字，Start URL后面的文本框内输入要抓取的网站入口网址https://block.cc/,最后点击按钮Create Sitemap，这样我们就创建了一个名字为block-cc的网站地图，这是我们想抓取数据的网站入口，也就是起点。 设置Sitemap 在页面最下面找到一个蓝色的按钮Add new selector,点击创建选择器，会弹出来选择器设置页面，有下面几项，我们一一解释 Id ———-这个Id需要自定义，最好定义一个英文名字，原则就是简洁，好记。Type ——-这个类型很重要，其实经常用的就三类：“文本”，”链接”，”元素”Selector —-这个是选择器，第一个按钮Select，当按下时，在网页上点击后出现绿色框。 其实重要的是捋清楚网页结构，搞清除哪些是文本，哪些是链接，哪些是元素，爬虫就很简单了。 点击网页最下面的蓝色按钮Add new selector创建一个选择器，Id设置为elemment-box,Type设置为Element, 点击Selector后面的Select按钮，鼠标移动到网页中，定位到币种列表下第一项BTC-比特币最右边，是不是出现个绿色框，当如下图所示状态时，代表已经选中此行，点击，第一行变红，继续点击下一行，所有行都变成红色就可以了。 点击Done selecting!确认选中目标，字段会自动填充到Selector后面的文本框中 勾选上Multiple,最后点击Save selector保存，这样我们的一个选择器就创建成功了。 想想为什么我们创建一个类型为元素的选择器，其实看看网页结构就清楚了，我们要抓取的数据都包裹在一个个容器中，我们需要先抓取容器，共50行，下面抓取每一行内容。 确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name,Type为Text，当点击选择按钮后，选择名称下面的容器，别选择容器内文本，确认后面字段为span.mgl10,不需要选择multiple,直接Save selector就可以了 确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为num,Type为Text，当点击选择按钮后，选择#下面的容器，别选择容器内文本，确认后面字段为div.col-md-1.col-xs-1,不需要选择multiple,直接Save selector就可以了 确认当前目录为_root/element-box,点击底部的Add new selector按钮，创建一个子集选择器，设置Id为name-link,Type为Link，当点击选择按钮后，选择名称下面的容器，确认后面字段为div.col-md-3 a,不需要选择multiple,直接Save selector就可以了 下面我们抓取子页面的内容，先点击BTC-比特币的链接，进入子页面，然后进入name-link目录，在此目录下分别创建web,amout,resum，whitepaper,四个选择集 web选择集设置Type为Text，Selector后面字段为p.col-sm-4:nth-of-type(1) a amout选择集设置Type为Text，Selector后面字段为div.col-xs-6 p.num resum选择集设置Type为Text，Selector后面字段为p.break-line-4 whitepaper选择集设置Type为Link,Selector后面字段为p.col-sm-4:nth-of-type(6) a 抓取数据 完成上面的设置后，点击Sitemap block的下拉菜单选择scrape,保持延迟为默认2000，点击蓝色按钮Start scraping就开始抓取数据了. 步骤四：导出数据导出到Excel表格 抓取结束后，点击Sitemap block，从下拉菜单选择Export data as CSV，等待一秒后，点击蓝色的Download now!选择保存路径，我存在了Downloads文件夹下了。 对数据进行筛选 从Finder找到Downloads文件夹下的block.csv文件，右键选择Numbers打开，删掉不需要的列，仅保留需要的列，最后我们可以用Numbers右上角的Sort&amp;Filter,点击Add a Column,选择num排序,这样就和网站列表次序一致了，结果见下图 总结众里寻他千百度，蓦然回首，那人却在灯火阑珊处。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言系列之环境搭建-虚拟机ubuntu环境配置]]></title>
    <url>%2F2018%2F01%2F31%2Fgo3%2F</url>
    <content type="text"><![CDATA[假设你的电脑是mac电脑，先下载ubuntu-16.04.3-desktop-amd64安装包到本地,并且下载一个虚拟机VirtualBox-5.2.4-119785-OSX。 快速开始安装ubuntu操作系统按照次序安装，先安装VirtualBox,安装后运行，在 Oracle VM VirtualBox Manager主界面选择New创建一个Name为Yourname,Type为Linux,Version为Ubuntu(64-bit)后选择蓝色按钮Continue进入下一界面，设置Memory size为默认，继续下一步，设置File location and size为20G到50G之间就可以。 配置虚拟机ubuntu]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言系列之管道分析]]></title>
    <url>%2F2018%2F01%2F31%2Fgo2%2F</url>
    <content type="text"><![CDATA[关键字：管道，同步，异步，缓冲管道，非缓冲管道，死锁 创建管道1c := make(chan int, 1)//创建一个管道 读写数据12c &lt;- 10 //写入数据，这条管道只能写入int类型&lt;-c //从管道里面取值 同步和异步1a, ok := &lt;-c //同步 缓冲管道和非缓冲管道12c := make(chan int) //非缓冲管道c := make(chan int，10) //缓冲管道 管道的长度和容量管道遵循先进先出的阵列原则。12len()cap() 管道的作用1管道是多个线程之间传递数据和同步数据的重要手段。 管道操作关闭管道可以用下面命令1close(c) 死锁我们知道管道有长度和容量，数据进入管道后，就可以按照顺序读取出来，假如管道中无数据，那读取的是一个空管道，这时候会发生什么，请看下面完整案例12345678910111213141516171819202122232425262728293031import ( &quot;fmt&quot;)func main() &#123; c := make(chan int) done := make(chan bool) go func() &#123; for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; done &lt;- true &#125;() go func() &#123; for i := 0; i &lt; 10; i++ &#123; c &lt;- i &#125; done &lt;- true &#125;() &lt;-done //死锁 &lt;-done close(c) for n := range c &#123; fmt.Println(n) &#125;&#125; 管道检测123for n := range c &#123; fmt.Println(n)&#125; 深刻理解 开关 //动作 读写 //动作 生产者 //对象 消费者 //对象 人机对话用机器类比跑一下用人类比跑一下]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[孔壹学院区块链培训课程大纲-解读]]></title>
    <url>%2F2018%2F01%2F30%2Fgo1%2F</url>
    <content type="text"><![CDATA[课程大纲上面是区块链修炼记的总览，对与区块链不了解的朋友，初次见到可能会感叹：好专业啊，怎么都看不懂那，下面请听我来解读解读。 课程大纲工欲善其事必先利其器，同样道理，区块链开发应先选择一种利器，这就是go语言，有了工具，我们就可以开始打磨精美玉器，但是价值不菲的美玉不会轻易示人，必有精美的盒子，如果用精美的盒子类比区块链，这一容器承载着的代币可类比为美玉。 我如此这么说只是不想让人认为区块链是什么高深的东西，其实很早就已经存在于人类历史中，只是换了一种说法，人话换成了计算机语言。 Go语言说到了计算机语言，和人类语言一样一样的，相反人类语言比计算机语言复杂多了，计算机只有0和1，人类还有26个字母。 go语言基础语言需要环境，go语言运行的环境，选择的是linux操作系统-ubutun接下来讲解的是go语言的基本语法，分别是变量，常量，类型和函数。 常用算法算法是什么那，就是计算机处理数据的方法，数据从你那到我这里可以直着走，也可以绕圈圈，尴尬的是数据一绕圈圈人就蒙圈，算法中有一个求质数算法，貌似和加密解密关系密切，求质数过程就是加密过程，分解质因数过程就是解密过程。 go语言高级编程面向对象编程并发编程网络编程工程管理 React Html css ES6 react Flux Redux 以太坊智能合约开发Solidity密码学共识算法超级账本环境搭建编译案例比特币和比特股源码分析比特币分析比特股分析实际项目-开发一条链 提出需求，解决问题 想像空间很大 总结天欲其亡，必令其狂]]></content>
      <categories>
        <category>Go语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用框架Hexo在Github上搭建个人博客]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo+Github [Mac环境]假如你有一个Github帐号，我们就可以开始了，如果你说没有，就去注册好了。想想咱们注册微信时也不是很难的事吧，准备好一个邮箱就行了，真的别的都不需要。 快速开始在 Github 上创建一个仓库（Repo）登陆Github网址，用你的账号登陆进去，点右上角的+，弹出菜单选择New repository,在弹出的Repository name下面的文本框内按照yourname.github.io 这种格式输入，然后选中 Public, 最后点击绿色的Create repository创建成功。 重新登陆，点右上角你的头像，在弹出的菜单中选中Your profile,会发现“youname.github.io”分支创建成功，点击进去，在右边找到Settings,在左侧栏最下面找到Deploy keys,点击Add deploy key,输入你的”key”,密匙的求解过程请参见Git密匙,至此你的远程仓库部分已经配置完成。 如果你对git很感兴趣，或者，对git的命令行方式很头疼的，可以阅读此物: Git入门教材 ⚠️我的git仓库名字为zhaodongchun.github.io,你的就用你自己的名字好了. 确认本地已经安装好 git 和 npm在终端输入下面两条命令，确认已经安装好git和npm,如果电脑还没装这两个东西的，请参照官方文档安装：Git入门教材+npm中文文档 12git --versionnpm --version 安装 hexo先通读官方文档hexo自动部署网站,不需要看内容，快速翻一遍知道有这个工具在这里就可以了，以后需要时再调用它。然后终端输入以下命令12npm install hexo -gnpm install hexo-cli -g 创建本地工作目录先登陆到github，点击你的分支yourname.github.io,在右边有个绿色的按钮Clone or download,点开后点击copy to clipboard把自己的git地址拷贝出来，在终端cd到你希望把站点放置的位置，下面我cd到Desktop了 12cd ~/Desktopgit clone https://github.com/zhaodongchun/zhaodongchun.github.io.git 初始化你的本地站点12345hexo init yourname.github.iocd yourname.github.ionpm install hexo-deployer-git --savehexo generatehexo server 在终端打完以上命令后，如果最后显示Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了，需要注意的是这个效果是hexo默认模版landscape的效果，下面我们学学怎么更换模版为Next模版。 设置个人模版这里涉及两个东西，一个是Hexo,一个是Next,我们先到Hexo模版，先看看都有哪些模版可供我们选择，如果你点击模版下面的大标题名字后会进入到github的源文件地址，和创建本地工作目录一样，可以把它的Git地址拷贝出来。先以next模版为例，先定位到Hexo站点目录下，在终端输入以下命令安装 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 安装完成后，修改配置文件_config.yml中的 theme 字段为 next后保存，至此我们完成了站点配置。在终端继续输入以下命令完成模版调试，如果再此出现Database saved，代表本地站点已经初始化完成，可以终端里按住ctrl的同时点击http://localhost:4000/查看你的站点了 1hexo server --debug 使用Atom码文章先把Atom下载下来，官网直接下载安装或在终端输入下面命令也可以，如果对Atom还不熟悉没关系，先从官方文档开始逐渐建立Atom语法吧，在线阅读:飞行手册 给 Atom 安装一个命令行面板，Atom 里同时按command+，调出setting面板，定位到install选项，在文本框中搜索platformio-ide-terminal后点击install安装atom包，安装完成后按command+shift+t在下面会出现一个终端，这个包的作用就是解决总是来回切换atom和终端的问题。 完成上面的操作后，我们对包大概有了个概念，下面继续安装一个markdown包，点击Atom菜单下的Preference的左侧倒数第二项+ install，输入markdown，依次安装几个包 markdown-scroll-synclinter-markdownmarkdown-writermarkdown-tocmarkdown-pdfmarkdown-preview 然后就是随便折腾一会，看看这几个都实现什么功能，接下来用markdown书写文章的过程中会经常使用这几个包/Desktop/zhaodongchun.github.io/zhaodongchun.github.io,这是我的目前位置，你可以在mac终端输入ls查看你是否在根路径下，然后终端输入atom .在atom中打开所有文件，然后使用快捷键command+shift+t打开atom终端，mac的终端就可以关闭了，在左侧栏定位到source文件夹下的_posts文件夹，展开后有一个hello-world.md文件，这个文件就是网站上看到的源文件。我们用一下刚才掌握的几个快捷键试试 command+w 关闭当前标签command+shift+m 终端ctrl+shift+m 预览 “&gt;” 块引用 “-” 任务列表“0.” 有序列表 快捷键熟悉差多了，再回去翻翻Next模版，设置下站点配置文件和主题配置文件，设置语言和你的昵称，基本上博客就可以了，保存后在终端输入下面调试命令,如果再此出现Database saved，代表本地站点已经初始化完成，可以在浏览器输入http://localhost:4000/查看你的站点了。 1hexo server --debug 部署到 Github 上把本地文件上传到github远程前，我们需要告诉atom上传到的路径，先登陆github，进入zhaodongchun.github.io这个分支，点击绿色的clone or download按钮拷贝出来路径，再进入atom，左侧根目录会有一个_config.yml文件，下面我们设置下这个配置文件，先把拷贝出来的路径粘贴到url后面，注意截止到/,将root后面改成你的github上的仓库一样，repo后面的直接把你拷贝出来的粘贴就行了，注意:后面的空格不要少，这样atom就知道上传给谁了。 url: https://github.com/konglongyinger/zhaodongchun.github.io/ root: /zhaodongchun.github.io deploy: type: git repo: https://github.com/konglongyinger/zhaodongchun.github.io.git 修改完成后保存，在atom终端输入下面命令，在github上查看上传结果，如果发现文件已经显示，就可以进入github你的分支下的settings，往下翻找到GitHub Pages这里，将source下的None改为master branch,点击保存后，会出现绿色的一条提示Your site is published at https://konglongyinger.github.io/zhaodongchun.github.io/，后面链接就是你的网址了，现在你可以点击看看效果。 1hexo deploy 调试网站如果每次在本地修改文章，可以用下面命令调试预览 1hexo s --debug 如果改动了配置文件，在上传到github前最好使用清理命令，清除public目录 1hexo clean 如果完成阶段性任务了可以用下面命令上传到github 1hexo deploy 域名绑定首先你的有个域名，举例来说我是从百度买的，有了域名后再分三步走。 配置CNAME 在hexo文件夹下的source中新建一个文本文档， 里边输入刚才我们买到的域名的二级域名。举例来说，我申请的是zhaodongchun.com，就填写zhaodongchun.com,然后保存为CNAME.注意大写的CNAME. 配置解析服务器 接下来进域名服务商的后台进行域名解析设置,添加CNAME记录类型，解析线路默认就好了，记录值为zhaodongchun.github.io,配置好后我们本地重新上传到github。 配置站点设置文件重定向 还记得我们没有绑定域名之前设置的配置文件吗，绑定域名后需要重新设置下url和root,否则css有可能会丢失，将其设置回默认，如下设置： url: https://zhaodongchun.comroot: / 好，到此为止，重新执行下面命令将文件上传到github，浏览器输入你的域名就可以正常登陆了。 123hexo cleanhexo ghexo d 总结千呼万唤始出来 犹抱琵琶半遮面]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
